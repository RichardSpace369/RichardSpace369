---
title: 对象
author: richard
toc: true
excerpt: 从对象角度来看到Object
categories:
- javascript
- 对象
---


##  对象得属性
ECMA-262 将对象定义为一组属性的无序集合。严格来说，这意味着对象就是一组没有特定顺序的
值。对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值。正因为如此（以及其他还未
讨论的原因），可以把 ECMAScript 的对象想象成一张散列表，其中的内容就是一组名/值对，值可以是
数据或者函数

###  数据属性
>数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。数据属性有 4个特性描述它们的行为

1. [[Configurable]]：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特
性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特
性都是 true，如前面的例子所示。
2. [[Enumerable]]：表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对
象上的属性的这个特性都是 true，如前面的例子所示。
3. [[Writable]]：表示属性的值是否可以被修改。默认情况下，所有直接定义在对象上的属性的
这个特性都是 true，如前面的例子所示。
4. [[Value]]：包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。这个特性
的默认值为 undefined

如果要实现对对象得数据属性修改需要使用Object.defineProperties和Object.defineProperty两个方法


###  访问器属性

访问器属性不包含数据值。相反，它们包含一个获取（getter）函数和一个设置（setter）函数，不
过这两个函数不是必需的。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效
的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改


1. [[Configurable]]：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特
性，以及是否可以把它改为数据属性。默认情况下，所有直接定义在对象上的属性的这个特性
都是 true。 
2.  [[Enumerable]]：表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对
象上的属性的这个特性都是 true。 
3. [[Get]]：获取函数，在读取属性时调用。默认值为 undefined。 
4. [[Set]]：设置函数，在写入属性时调用。默认值为 undefined。

**利用GET和Set可以一定程度上实现私有属性**

### 对象属性的访问和删除

### 对象的遍历

##  创建对象
### 字面量创建

### 利用Object函数创建

1. 如果给定值是 null 或 undefined，将会创建并返回一个空对象
2. 如果传进去的是一个基本类型的值，则会构造其包装类型的对象
3. 如果传进去的是引用类型的值，仍然会返回这个值，经他们复制的变量保有和源对象相同的引用地址

###  工厂模式
>抽象创建特定对象的过程

**缺点：没有解决对象标识问题(即创建的对象是什么类型)**
```
function createPerson(name, age, job) { 
 let o = new Object(); 
 o.name = name; 
 o.age = age; 
 o.job = job; 
 o.sayName = function() { 
 console.log(this.name); 
 }; 
 return o; 
} 
let person1 = createPerson("Nicholas", 29, "Software Engineer"); 
let person2 = createPerson("Greg", 27, "Doctor");
```
### 构造函数模式

```
function Person(name, age, job){ 
 this.name = name; 
 this.age = age; 
 this.job = job; 
 this.sayName = function() { 
 console.log(this.name); 
 }; 
} 
let person1 = new Person("Nicholas", 29, "Software Engineer"); 
let person2 = new Person("Greg", 27, "Doctor"); 
person1.sayName(); // Nicholas 
person2.sayName(); // Greg

```

**理解new 操作符**
1. 在内存中创建一个新对象
2. 新对象的内部的[[Prototype]]特性被赋值为构造函数的prototype属性
3. 构造函数内部的this被赋值为这个新对象
4. 执行构造函数内部的代码(给新对象添加属性)
5. 如果构造函数返回非空对象，则返回该对象否则返回刚创建的新对象

**理解构造函数的缺点**

构造函数虽然解决了对象标识的问题，但是也带来了其他问题，如果构造函数内部有一个函数，那么每次在实例化的时候，都会重新创建这个函数，而不能实现复用，如果将这个函数放在外部，会导致代码不能聚集

### 原型模式
>使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型

```
function Person() {} 
Person.prototype.name = "Nicholas"; 
Person.prototype.age = 29; 
Person.prototype.job = "Software Engineer"; 
Person.prototype.sayName = function() { 
 console.log(this.name); 
}; 
let person1 = new Person(); 
person1.sayName(); // "Nicholas"
```

**理解原型模式的缺点：共享引用类型的数据**
### 构造函数和原型混合的模式
```
      function Person(name, age) {
				this.name = name;
				this.age = age;
			}
			Person.prototype.say = function() {};
```

###  基于动态原型模式
>动态原型模式是将原型对象放在构造函数内部，通过变量进行控制，只在第一次生成实例的时候进行原型的设置

动态原型的模式相当于懒汉模式，只在生成实例时设置原型对象，但是功能与构造函数和原型混合模式是相同的

```
// 动态原型模式
			function Person(name, age, address) {
				this.name = name;
				this.age = age;
				this.address = address;
				// 如果Person对象中_initialized 为undeﬁned，则表明还没有为Person的原型对象添加函数
				if (typeof Person._initialized === 'undeﬁned') {
					Person.prototype.getName = function() {
						return this.name;
					};
					Person._initialized = true;
				}
			}
```
## 继承

### 原型链继承
```
function SuperType() { 
 this.property = true; 
} 
SuperType.prototype.getSuperValue = function() { 
 return this.property; 
}; 
function SubType() { 
 this.subproperty = false; 
}
// 继承 SuperType 
SubType.prototype = new SuperType(); 
let instance = new SubType();
```

**理解原型链继承的缺点：**
1. 在使用原型实现继承时，原型实际上变成了另一个类型的实例。这意味着原先的实例属性摇身一变成为了原型属性
2. 子类型在实例化时不能给父类型的构造函数传参

### 盗用构造函数
>在子类构造函数中调用父类构造函数。因为毕竟函数就是在特定上下文中执行代码的简单对象，所以可以使用apply()和 call()方法以新创建的对象为上下文执行构造函数
```
function SuperType() { 
 this.colors = ["red", "blue", "green"]; 
} 
function SubType() { 
 // 继承 SuperType 
 SuperType.call(this); 
} 
let instance1 = new SubType(); 
instance1.colors.push("black"); 
console.log(instance1.colors); // "red,blue,green,black" 
let instance2 = new SubType(); 
console.log(instance2.colors); // "red,blue,green"
```

**理解盗用构造函数继承的缺点:必须在构造函数中定义方法因此函数不能重用。此外，子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式**


### 组合继承
>使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性

**组合继承弥补了原型链和盗用构造函数的不足，是 JavaScript 中使用最多的继承模式。而且组合继承也保留了 instanceof 操作符和 isPrototypeOf()方法识别合成对象的能力**
```
function SuperType(name){ 
 this.name = name; 
 this.colors = ["red", "blue", "green"]; 
} 
SuperType.prototype.sayName = function() { 
 console.log(this.name); 
}; 
function SubType(name, age){ 
 // 继承属性
 SuperType.call(this, name); 
 this.age = age; 
} 
// 继承方法
SubType.prototype = new SuperType(); 
SubType.prototype.sayAge = function() { 
 console.log(this.age); 
}; 
let instance1 = new SubType("Nicholas", 29); 
instance1.colors.push("black"); 
console.log(instance1.colors); // "red,blue,green,black" 
instance1.sayName(); // "Nicholas"; 
instance1.sayAge(); // 29 
let instance2 = new SubType("Greg", 27); 
console.log(instance2.colors); // "red,blue,green" 
instance2.sayName(); // "Greg"; 
instance2.sayAge(); // 27
```
**理解组合继承的缺点：组合继承其实也存在效率问题。最主要的效率问题就是父类构造函数始终会被调用两次**

### 原型链继承


**使用场景**
你有一个对象，想在它的基础上再创建一个新对象。你需要把这个对象先传给 object()，然后再对返回的对象进行适当修改

```
function object(o) { 
 function F() {} 
 F.prototype = o; 
 return new F(); 
}
```
ECMAScript 5 通过增加 Object.create()方法将原型式继承的概念规范化了

### 寄生式继承
>创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象
```
function createAnother(original){ 
 let clone = object(original); // 通过调用函数创建一个新对象
 clone.sayHi = function() { // 以某种方式增强这个对象
 console.log("hi"); 
 }; 
 return clone; // 返回这个对象
}
```
**注意:通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似。**


### 寄生式组合继承
>寄生式组合继承通过盗用构造函数继承属性，但使用混合式原型链继承方法。基本思路是不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本

**寄生式组合继承可以算是引用类型继承的最佳模式**
```
function inheritPrototype(subType, superType) { 
 let prototype = object(superType.prototype); // 创建对象
 prototype.constructor = subType; // 增强对象 
 subType.prototype = prototype; // 赋值对象
}

function SuperType(name) { 
 this.name = name; 
 this.colors = ["red", "blue", "green"]; 
} 
SuperType.prototype.sayName = function() { 
 console.log(this.name); 
}; 
function SubType(name, age) { 
 SuperType.call(this, name);
  this.age = age; 
} 
inheritPrototype(SubType, SuperType); 
SubType.prototype.sayAge = function() { 
 console.log(this.age); 
};
```

##  对象克隆
>克隆是指通过一定的程序将某个变量的值复制至另一个变量的过程。根据复制后的变量与原始变量值的影响情况，克隆可以分为浅克隆和深克隆两种方式


### 浅克隆
1. 简单得引用赋值
   ```
    function shallowClone(origin) {
      var result = {};
      // 遍历最外层属性
      for (var key in origin) {
          // 判断是否是对象自身的属性
          if (origin.hasOwnProperty(key)) {
              result[key] = origin[key];
          }
      }
      return result;
    }
   ```
2. Object.assign

### 深克隆

1. JSON序列化和反序列化

这种方法能够解决大部分JSON类型对象的深克隆问题，但是对于以下几个问题不能很好地解决。


 - 无法实现对函数、RegExp等特殊对象的克隆。
 - 对象的constructor会被抛弃，所有的构造函数会指向Object，原型链关系断裂。
 - 对象中如果存在循环引用，会抛出异常
2. 自定义，利用数据类型判断和递归来解决json序列化得问题


## 遍历

### for...in

使用for..in遍历对象是无法直接获取属性值的，因为它实际上遍历的是对象中的所有可枚举属性，你需要手动获取属性值。

### for...of

for..of循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next()方法来遍历所有返回值。