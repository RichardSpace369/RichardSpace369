---
title: 二分查找法
author: richard
toc: true
excerpt: 彻底掌握二分查找法...
categories:
- 数据结构与算法
---

折半查找（Binary Search）又称为二分查找。它要求数据序列呈线性结构，也就是要保证需要查找的**数据序列是有序的**。对于没有经过排序的数据，可以通过排序算法进行预排序，然后进行折半查找的操作

折半查找的具体过程是：假设有n个元素的查找表，首先计算位于查找表中间位置元素的序号m（m=n/2），取s[m]的关键字与给定值key进行比较，其中s[m]是这个有序序列（查找表）的中间分界点，它将有序序列分为前半部分和后半部分。比较结果有3种可能



（1）若s[m]=key，表示查找成功。
（2）若s[m]>key，表示关键字key只可能在查找表的前半部分（因查找表中的数据是按从小到大的顺序排列），则在前半部分继续进行折半查找。

（3）若s[m]\<key，表示关键字key只可能在查找表的后半部分，则在后半部分继续进行折半查找。


·优点：查找速度快，最多查找次数为O（nlog2n）


·缺点：对查找表中的数据有顺序要求，在进行查找前可使用上一章介绍的方法首先进行排序。如果需要将查找不成功的关键字数据添加到查找表中，则需要对查找表中的已有数据进行大量的移动操作。

## 二分查找实现


⼆分搜索的经典写法。需要注意的三点：
1. 循环退出条件，注意是 low <= high，⽽不是 low < high。
2. mid 的取值，mid := low + (high-low)>>1
3. low 和 high 的更新。low = mid + 1，high = mid - 1。

这个地方需要着重一点：就是递归实现和非递归实现都应该掌握

非递归实现
```
        function binSearch(arr, data) {
          var upperBound = arr.length-1;
          var lowerBound = 0;
          while (lowerBound ＜= upperBound) {
              var mid = Math.floor((upperBound + lowerBound) / 2);
              if (arr[mid] ＜ data) {
                lowerBound = mid + 1;
              }else if (arr[mid] ＞ data) {
                upperBound = mid - 1;
              }else {
                return mid;
              }
          }
          return -1;
        }
```

递归实现

```
function binSearch(arr, target) {
				let left = 0;
				let right = arr.length - 1;
				return find(arr, target, left, right);
			}
			function find(data, target, start, end) {
				if (start > end) {
					return -1;
				}
				let middle = Math.floor(start + (end - start) / 2);
				if (data[middle] === target) {
					return middle;
				} else if (data[middle] < target) {
					return find(data, target, middle + 1, end);
				} else {
					return find(data, target, start, middle - 1);
				}
				return -1;
			}
			console.log(binSearch([1, 2, 3, 4, 5, 6, 7], 3));
```

### 二分查找的6种变形

#### 查找第一个等于target的元素

```
function findFirstLess(arr, target) {
	let left = 0,
		right = arr.length - 1;
	while (left <= right) {
		let middle = Math.floor(left + (right - left) / 2);
		if (arr[middle] > target) {
			right = middle - 1;
		} else if (arr[middle] < target) {
			left = middle + 1;
		} else {
			if (middle === 0 || arr[middle - 1] != target) {
				return middle;
			}
			right = middle - 1;
		}
	}
	return left;
}
```
#### 查找最后一个与target相等的元素

```
function findLastLess(arr, target) {
	let left = 0,
		right = arr.length - 1;
	while (left <= right) {
		let middle = Math.floor(left + (right - left) / 2);
		if (arr[middle] > target) {
			right = middle - 1;
		} else if (arr[middle] < target) {
			left = middle + 1;
		} else {
			if (middle === arr.length - 1 || arr[middle + 1] != target) {
				return middle;
			}
			left = middle + 1;
		}
	}
	return left;
}
```

#### ⼆分查找第⼀个⼤于等于 target 的元素，时间复杂度 O(logn)



#### 查找最后一个小于key的元素


#### 查找最后一个小于key的元素




##  leetcode题目
