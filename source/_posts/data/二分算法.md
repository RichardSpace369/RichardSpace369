---
title: 二分查找法
author: richard
toc: true
excerpt: 彻底掌握二分查找法...
categories:
- 数据结构与算法
---

折半查找（Binary Search）又称为二分查找。它要求数据序列呈线性结构，也就是要保证需要查找的**数据序列是有序的**。对于没有经过排序的数据，可以通过排序算法进行预排序，然后进行折半查找的操作

折半查找的具体过程是：假设有n个元素的查找表，首先计算位于查找表中间位置元素的序号m（m=n/2），取s[m]的关键字与给定值key进行比较，其中s[m]是这个有序序列（查找表）的中间分界点，它将有序序列分为前半部分和后半部分。比较结果有3种可能



（1）若s[m]=key，表示查找成功。
（2）若s[m]>key，表示关键字key只可能在查找表的前半部分（因查找表中的数据是按从小到大的顺序排列），则在前半部分继续进行折半查找。

（3）若s[m]\<key，表示关键字key只可能在查找表的后半部分，则在后半部分继续进行折半查找。


·优点：查找速度快，最多查找次数为O（nlog2n）


·缺点：对查找表中的数据有顺序要求，在进行查找前可使用上一章介绍的方法首先进行排序。如果需要将查找不成功的关键字数据添加到查找表中，则需要对查找表中的已有数据进行大量的移动操作。


何时使用：


二分算法成立的关键在于单调性，因此任何具有单调性的问题，我们都可以考虑在其上使用二分算法的可能性。正是基于这一点，当问题的答案具有单调性时，我们可以通过二分将「问题的求解」转化为「问题的判定」，该方法即为「二分答案」。



## 二分查找实现


⼆分搜索的经典写法。需要注意的三点：
1. 循环退出条件，注意是 low <= high，⽽不是 low < high。
2. mid 的取值，mid := low + (high-low)>>1
3. low 和 high 的更新。low = mid + 1，high = mid - 1。

这个地方需要着重一点：就是递归实现和非递归实现都应该掌握

非递归实现
```
        function binSearch(arr, data) {
          var upperBound = arr.length-1;
          var lowerBound = 0;
          while (lowerBound ＜= upperBound) {
              var mid = Math.floor((upperBound + lowerBound) / 2);
              if (arr[mid] ＜ data) {
                lowerBound = mid + 1;
              }else if (arr[mid] ＞ data) {
                upperBound = mid - 1;
              }else {
                return mid;
              }
          }
          return -1;
        }
```

递归实现

```
function binSearch(arr, target) {
				let left = 0;
				let right = arr.length - 1;
				return find(arr, target, left, right);
			}
			function find(data, target, start, end) {
				if (start > end) {
					return -1;
				}
				let middle = Math.floor(start + (end - start) / 2);
				if (data[middle] === target) {
					return middle;
				} else if (data[middle] < target) {
					return find(data, target, middle + 1, end);
				} else {
					return find(data, target, start, middle - 1);
				}
				return -1;
			}
			console.log(binSearch([1, 2, 3, 4, 5, 6, 7], 3));
```

### 二分查找的6种变形

#### 查找第一个等于target的元素

```
function findFirstLess(arr, target) {
	let left = 0,
		right = arr.length - 1;
	while (left <= right) {
		let middle = Math.floor(left + (right - left) / 2);
		if (arr[middle] > target) {
			right = middle - 1;
		} else if (arr[middle] < target) {
			left = middle + 1;
		} else {
			if (middle === 0 || arr[middle - 1] != target) {
				return middle;
			}
			right = middle - 1;
		}
	}
	return left;
}
```
#### 查找最后一个与target相等的元素

```
function findLastLess(arr, target) {
	let left = 0,
		right = arr.length - 1;
	while (left <= right) {
		let middle = Math.floor(left + (right - left) / 2);
		if (arr[middle] > target) {
			right = middle - 1;
		} else if (arr[middle] < target) {
			left = middle + 1;
		} else {
			if (middle === arr.length - 1 || arr[middle + 1] != target) {
				return middle;
			}
			left = middle + 1;
		}
	}
	return left;
}
```

#### ⼆分查找第⼀个⼤于等于 target 的元素，时间复杂度 O(logn)



#### 查找最后一个小于key的元素


#### 查找最后一个小于key的元素




##  leetcode题目
### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)


解题思路：

两次循环，第一次找到最左侧相等元素，第二次找到最右侧相等元素
这里的关键不是找到了相等元素就停止，而是继续在左侧或者右侧继续找是否有相同元素


```
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var searchRange = function(nums, target) {
   let left = 0,
		right = nums.length - 1;
	let ans1, ans2;
	// 这一次遍历是找到最左侧
	while (left <= right) {
		let middle = Math.floor(left + (right - left) / 2);
		if (nums[middle] >= target) {
			ans1 = middle;
			right = middle - 1;
		} else {
			left = middle + 1;
		}
	}
	left = 0;
	right = nums.length - 1;
	// 这一次遍历是找到最右侧
	while (left <= right) {
		let middle = Math.floor(left + (right - left) / 2);
		if (nums[middle] <= target) {
			ans2 = middle;
			left = middle + 1;
		} else {
			right = middle - 1;
		}
	}
	if (nums.length && nums[ans1] === target) {
		return [ans1, ans2];
	}
	return [-1, -1];


};
```

### [287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)


题目描述：


给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。

假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。

题解：

这个题目难在对解法的限制
1. 你可以在不修改数组 nums 的情况下解决这个问题吗？(排除了 先排序的解法)
2. 你可以只用常量级 O(1) 的额外空间解决这个问题吗？(排除了简历hashTable方法)
3. 你可以设计一个时间复杂度小于 O(n^2) 的解决方案吗？(排除了 双重循环)

#### 解法一   二分查找法

既然是对某个数的定位，我们想到是不是可以用二分法，但是和传统二分不一样的是，我们对要**定位的“数”做二分，而不是对数组的索引做二分**。要定位的“数”根据题意在 1 和 n 之间，每一次二分都可以将搜索区间缩小一半。

以 [1, 2, 2, 3, 4, 5, 6, 7] 为例，一共有 8 个数，每个数都在 1 和 7 之间。1 和 7 的中位数是 4，遍历整个数组，统计小于 4 的整数的个数，至多应该为 3 个，如果超过 3 个就说明重复的数存在于区间 [1,4) （注意：左闭右开）中；


否则，重复的数存在于区间 [4,7]（注意：左右都是闭）中。这里小于 4 的整数有 4 个（它们是 1, 2, 2, 3），因此砍掉右半区间，连中位数也砍掉。

以此类推，最后区间越来越小，直到变成 1 个整数，这个整数就是我们要找的重复的数，时间复杂度是 [公式] 。

```
var findDuplicate = function(nums) {
	let left = 1,
		right = nums.length - 1;
	while (left < right) {
		let mid = Math.floor(left + (right - left) / 2); // 这个地方不是下标,而是值
		let counter = 0;// counter 这里记录的是有多少个小于等于中位数
		for (let i = 0; i < nums.length; ++i) {
			// 如果小于等于中位数，则进行累加记录
			if (nums[i] <= mid) {
				++counter;
			}
		}
        // 如果累加值已经大于中位数了，则直接放弃右边
		if (counter > mid) {
			right = mid;
		} else {
			left = mid + 1;
		}
	}
	return left;
};
```