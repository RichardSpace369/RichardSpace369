<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>性能优化-指标采集 - richardSpace</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="richardSpace"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="richardSpace"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="了解，掌握前端性能优化指标采集..."><meta property="og:type" content="blog"><meta property="og:title" content="性能优化-指标采集"><meta property="og:url" content="https://richardspace369.github.io/2021/03/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%8C%87%E6%A0%87%E9%87%87%E9%9B%86/"><meta property="og:site_name" content="richardSpace"><meta property="og:description" content="了解，掌握前端性能优化指标采集..."><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://richardspace369.github.io/img/og_image.png"><meta property="article:published_time" content="2021-03-10T10:04:37.345Z"><meta property="article:modified_time" content="2021-03-10T10:04:37.345Z"><meta property="article:author" content="richard"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://richardspace369.github.io/2021/03/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%8C%87%E6%A0%87%E9%87%87%E9%9B%86/"},"headline":"richardSpace","image":["https://richardspace369.github.io/img/og_image.png"],"datePublished":"2021-03-10T10:04:37.345Z","dateModified":"2021-03-10T10:04:37.345Z","author":{"@type":"Person","name":"richard"},"description":"了解，掌握前端性能优化指标采集..."}</script><link rel="canonical" href="https://richardspace369.github.io/2021/03/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%8C%87%E6%A0%87%E9%87%87%E9%9B%86/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">RichardSpace</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/RichardSpace369"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-10T10:04:37.345Z" title="3/10/2021, 10:04:37 AM">2021-03-10</time>发表</span><span class="level-item"><time dateTime="2021-03-10T10:04:37.345Z" title="3/10/2021, 10:04:37 AM">2021-03-10</time>更新</span><span class="level-item"> richard </span><span class="level-item"><a class="link-muted" href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></span><span class="level-item">25 分钟读完 (大约3821个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">性能优化-指标采集</h1><div class="content"><p>前端性能优化指标采集主要是包括如下几个方向</p>
<ol>
<li>首屏</li>
<li>白屏</li>
<li>卡顿</li>
<li>网络环境</li>
</ol>
<h2 id="首屏"><a href="#首屏" class="headerlink" title="首屏"></a>首屏</h2><p>在实际当中，首屏指标采集有手动采集和自动化采集两种</p>
<h3 id="手动采集办法及优缺点"><a href="#手动采集办法及优缺点" class="headerlink" title="手动采集办法及优缺点"></a>手动采集办法及优缺点</h3><p>所谓手动采集，一般是通过埋点的方式进行， 比如在页面开始位置打上 FMP.Start()，在首屏结束位置打上 FMP.End()，利用 FMP.End()-FMP.Start() 获取到首屏时间。</p>
<p>以电商平台为例，如果是电商类商品详情页，首屏包括头图、购买、商品信息、下单按钮等，就在这些内容加载完毕的位置打上首屏结束的点。</p>
<p>如果是电商列表页，瀑布流型的页面，需要根据各个机型下的首屏位置，估算一个平均的首屏位置，然后打上点。</p>
<p>如果是直播型的页面，页面核心是一个直播框，就需要在直播框的结束位置，打上点。</p>
<p>手动采集都有哪些优点和缺点呢？</p>
<p>首先是它兼容性强，业务同学知道在这个业务场景下首屏结束点在哪里，可以随情况变动。其次是去中心化，各个业务负责自己的打点代码，有问题时业务同学去排查即可，假如一条业务出现问题，并不会影响其他业务。</p>
<p>缺点方面，手动采集会和业务代码严重耦合，如果首屏采集逻辑调整，业务代码也需要修改；还有，它的覆盖率不足，因为要手动采集，业务一旦忙起来，性能优化方案就会延迟排后。</p>
<p>最后，手动采集的统计结果并不精确，因为依赖于人，每个人对首屏的理解有偏差，经常打错或者忘记打点。</p>
<h3 id="自动化采集优势及办法"><a href="#自动化采集优势及办法" class="headerlink" title="自动化采集优势及办法"></a>自动化采集优势及办法</h3><blockquote>
<p>所谓自动化采集，即引入一段通用的代码来做首屏时间自动化采集，引入过程中，除了必要的配置不需要做其他事情</p>
</blockquote>
<p>自动化采集的好处是独立性更强，接入过程更自动化。具体的自动化采集代码，可以由一个公共团队来开发，试点后，推广到各个业务团队。而且统计结果更标准化，同一段统计代码，标准更统一，业务侧同学也更认可这个统计结果。</p>
<p>当然，它也有缺点，最明显的是，有些个性化需求无法满足，毕竟在工作中，总会有一些特殊业务场景。所以，采用自动化采集方案必须做一些取舍。</p>
<p>既然是自动化采集，具体怎么采集呢？都有哪些办法？</p>
<p>首屏指标自动化采集，需要考虑是服务端模板业务，还是单页面（SPA）应用开发业务，业务场景不同，对应的采集方法也不同。下面我来分别介绍下。</p>
<h3 id="服务端模板业务下的采集办法"><a href="#服务端模板业务下的采集办法" class="headerlink" title="服务端模板业务下的采集办法"></a>服务端模板业务下的采集办法</h3><p>那服务端模板项目的加载流程是怎样的呢？</p>
<p>大致流程是这样的：HTTP 请求 → HTML 文档加载解析完成 → 加载样式和脚本文件 → 完成页面渲染。</p>
<p>其中，HTML 文档加载解析完成的时间点，就是首屏时间点，而要采集这个首屏时间，可以用浏览器提供的 DOMContentLoaded 接口来实现。</p>
<p>那么，DOMContentLoaded 时间具体的采集思路是怎样的呢？</p>
<p>当页面中的 HTML 元素被加载和解析完成（不需要等待样式表、图片和一些脚本的加载过程），DOMContentLoaded 事件触发。此时我们记录下当前时间 domContentLoadedEventEnd，再减去页面初始进入的时间 fetchStart，就是 DOMContentLoaded 的时间，也就是我们要采集的首屏时间。<br>即首屏时间=DOMContentLoaded 时间=domContentLoadedEventEnd-fetchStart。</p>
<p>那么，这种采集方法可以照搬到单页面应用下吗？答案是不可以。</p>
<h3 id="单页面（SPA）应用业务下的采集办法"><a href="#单页面（SPA）应用业务下的采集办法" class="headerlink" title="单页面（SPA）应用业务下的采集办法"></a>单页面（SPA）应用业务下的采集办法</h3><p>利用 MutationObserver </p>
<blockquote>
<p>MutationObserver 接口提供了监视对 DOM 树所做更改的能力。它被设计为旧的 Mutation Events 功能的替代品，该功能是 DOM3 Events 规范的一部分。</p>
</blockquote>
<p>简单来说， 使用 MutationObserver 能监控页面信息的变化，当页面 body 变化最剧烈的时候，我们拿到的时间数据，就是首屏时间。</p>
<p>但具体怎么做呢？</p>
<p>首先，在用户进入页面时，我们可以使用 MutationObserver 监控 DOM 元素 （Document Object Model，文档对象模型）。当 DOM 元素发生变化时，程序会标记变化的元素，记录时间点和分数，存储到数组中。数据的格式类似于 [200ms,18.5] 。</p>
<p>为了提升计算的效率，我们认为首屏指标采集到某些条件时，首屏渲染已经结束，我们需要考虑首屏采集终止的条件，即</p>
<ol>
<li><p>计算时间超过 30 秒还没有结束；</p>
</li>
<li><p>计算了 4 轮且 1 秒内分数不再变化</p>
</li>
<li><p>计算了 9 次且分数不再变化。</p>
</li>
</ol>
<p>接下来，设定元素权重计算分数。</p>
<p>递归遍历 DOM 元素及其子元素，根据子元素所在层数设定元素权重，比如第一层元素权重是 1，当它被渲染时得 1 分，每增加一层权重增加 0.5，比如第五层元素权重是 3.5，渲染时给出对应分数。</p>
<p>为什么需要权重呢？</p>
<p>因为页面中每个 DOM 元素对于首屏的意义是不同的，越往内层越接近真实的首屏内容，如图片和文字，越往外层越接近 body 等框架层。</p>
<p>最后，根据前面的得分，计算元素的分数变化率，获取变化率最大点对应的分数。然后找到该分数对应的时间，即为首屏时间。</p>
<p>分数部分核心计算逻辑是递归遍历元素，将一些无用的标签排除，如果元素超过可视范围返回 0 分，每一层增加 0.5 的权重，具体请看下面代码示例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function CScor(el, tiers, parentScore) &#123;</span><br><span class="line">    let score &#x3D; 0;</span><br><span class="line">    const tagName &#x3D; el.tagName;</span><br><span class="line">    if (&quot;SCRIPT&quot; !&#x3D;&#x3D; tagName &amp;&amp; &quot;STYLE&quot; !&#x3D;&#x3D; tagName &amp;&amp; &quot;META&quot; !&#x3D;&#x3D; tagName &amp;&amp; &quot;HEAD&quot; !&#x3D;&#x3D; tagName) &#123;</span><br><span class="line">      const childrenLen &#x3D; el.children ? el.children.length : 0;</span><br><span class="line">      if (childrenLen &gt; 0) for (let childs &#x3D; el.children, len &#x3D; childrenLen - 1; len &gt;&#x3D; 0; len--) &#123;</span><br><span class="line">        score +&#x3D; calculateScore(childs[len], tiers + 1, score &gt; 0);</span><br><span class="line">      &#125;</span><br><span class="line">      if (score &lt;&#x3D; 0 &amp;&amp; !parentScore) &#123;</span><br><span class="line">        if (!(el.getBoundingClientRect &amp;&amp; el.getBoundingClientRect().top &lt; WH)) return 0;</span><br><span class="line">      &#125;</span><br><span class="line">      score +&#x3D; 1 + .5 * tiers;</span><br><span class="line">    &#125;</span><br><span class="line">    return score;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>变化率部分核心计算逻辑是获取 DOM 变化最大时对应的时间，代码如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">calFinallScore() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      if (this.sendMark) return;</span><br><span class="line">      const time &#x3D; Date.now() - performance.timing.fetchStart;</span><br><span class="line">      var isCheckFmp &#x3D; time &gt; 30000 || SCORE_ITEMS &amp;&amp; SCORE_ITEMS.length &gt; 4 &amp;&amp; time - (SCORE_ITEMS &amp;&amp; SCORE_ITEMS.length &amp;&amp; SCORE_ITEMS[SCORE_ITEMS.length - 1].t || 0) &gt; 2 * CHECK_INTERVAL || (SCORE_ITEMS.length &gt; 10 &amp;&amp; window.performance.timing.loadEventEnd !&#x3D;&#x3D; 0 &amp;&amp; SCORE_ITEMS[SCORE_ITEMS.length - 1].score &#x3D;&#x3D;&#x3D; SCORE_ITEMS[SCORE_ITEMS.length - 9].score);</span><br><span class="line">      if (this.observer &amp;&amp; isCheckFmp) &#123;</span><br><span class="line">        this.observer.disconnect();</span><br><span class="line">        window.SCORE_ITEMS_CHART &#x3D; JSON.parse(JSON.stringify(SCORE_ITEMS));</span><br><span class="line">        let fmps &#x3D; getFmp(SCORE_ITEMS);</span><br><span class="line">        let record &#x3D; null</span><br><span class="line">        for (let o &#x3D; 1; o &lt; fmps.length; o++) &#123;</span><br><span class="line">          if (fmps[o].t &gt;&#x3D; fmps[o - 1].t) &#123;</span><br><span class="line">            let l &#x3D; fmps[o].score - fmps[o - 1].score;</span><br><span class="line">            (!record || record.rate &lt;&#x3D; l) &amp;&amp; (record &#x3D; &#123;</span><br><span class="line">              t: fmps[o].t,</span><br><span class="line">              rate: l</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        this.fmp &#x3D; record &amp;&amp; record.t || 30001;</span><br><span class="line">        try &#123;</span><br><span class="line">          this.checkImgs(document.body)</span><br><span class="line">          let max &#x3D; Math.max(...this.imgs.map(element &#x3D;&gt; &#123;</span><br><span class="line">            if(&#x2F;^(\&#x2F;\&#x2F;)&#x2F;.test(element)) element &#x3D; &#39;https:&#39; + element;</span><br><span class="line">            try &#123;</span><br><span class="line">              return performance.getEntriesByName(element)[0].responseEnd || 0</span><br><span class="line">            &#125; catch (error) &#123;</span><br><span class="line">              return 0</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;))</span><br><span class="line">          record &amp;&amp; record.t &gt; 0 &amp;&amp; record.t &lt; 36e5 ? this.setPerformance(&#123;</span><br><span class="line">            fmpImg: parseInt(Math.max(record.t , max))</span><br><span class="line">          &#125;) : this.setPerformance(&#123;&#125;);</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">          this.setPerformance(&#123;&#125;);</span><br><span class="line">          &#x2F;&#x2F; console.error(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">          this.calFinallScore();</span><br><span class="line">        &#125;, CHECK_INTERVAL);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个就是首屏计算的部分流程。</p>
<p>看完前面的流程，不知道你有没有这样的疑问：如果页面里包含图片，使用上面的首屏指标采集方案，结果准确吗？</p>
<p>结论是：不准确。上述计算逻辑主要是针对 DOM 元素来做的，图片加载过程是异步，图片容器（图片的 DOM 元素）和内容的加载是分开的，当容器加载出来时，内容还没出来，一定要确保内容加载出来，才算首屏。</p>
<p>这就需要增加一些策略了，以下是包含图片页面的首屏计算 demo。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;&lt;body&gt;&lt;img id&#x3D;&quot;imgTest&quot; src&#x3D;&quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;img&#x2F;bd_logo1.png?where&#x3D;super&quot;&gt;</span><br><span class="line">  &lt;img id&#x3D;&quot;imgTest&quot; src&#x3D;&quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;img&#x2F;bd_logo1.png?where&#x3D;super&quot;&gt;</span><br><span class="line">  &lt;style type&#x3D;text&#x2F;css&gt;</span><br><span class="line">    background-image:url(&#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;img&#x2F;dong_8f1d47bcb77d74a1e029d8cbb3b33854.gif);</span><br><span class="line">  &lt;&#x2F;style&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">  &lt;html&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">(() &#x3D;&gt; &#123;</span><br><span class="line">  const imgs &#x3D; []</span><br><span class="line">  const getImageDomSrc &#x3D; &#123;</span><br><span class="line">    _getImgSrcFromBgImg: function (bgImg) &#123;</span><br><span class="line">      var imgSrc;</span><br><span class="line">      var matches &#x3D; bgImg.match(&#x2F;url\(.*?\)&#x2F;g);</span><br><span class="line">      if (matches &amp;&amp; matches.length) &#123;</span><br><span class="line">        var urlStr &#x3D; matches[matches.length - 1];</span><br><span class="line">        var innerUrl &#x3D; urlStr.replace(&#x2F;^url\([\&#39;\&quot;]?&#x2F;, &#39;&#39;).replace(&#x2F;[\&#39;\&quot;]?\)$&#x2F;, &#39;&#39;);</span><br><span class="line">        if (((&#x2F;^http&#x2F;.test(innerUrl) || &#x2F;^\&#x2F;\&#x2F;&#x2F;.test(innerUrl)))) &#123;</span><br><span class="line">          imgSrc &#x3D; innerUrl;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return imgSrc;</span><br><span class="line">    &#125;,</span><br><span class="line">    getImgSrcFromDom: function (dom, imgFilter) &#123;</span><br><span class="line">      if (!(dom.getBoundingClientRect &amp;&amp; dom.getBoundingClientRect().top &lt; window.innerHeight))</span><br><span class="line">        return false;</span><br><span class="line">      imgFilter &#x3D; [&#x2F;(\.)(png|jpg|jpeg|gif|webp|ico|bmp|tiff|svg)&#x2F;i]</span><br><span class="line">      var src;</span><br><span class="line">      if (dom.nodeName.toUpperCase() &#x3D;&#x3D; &#39;IMG&#39;) &#123;</span><br><span class="line">        src &#x3D; dom.getAttribute(&#39;src&#39;);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        var computedStyle &#x3D; window.getComputedStyle(dom);</span><br><span class="line">        var bgImg &#x3D; computedStyle.getPropertyValue(&#39;background-image&#39;) || computedStyle.getPropertyValue(&#39;background&#39;);</span><br><span class="line">        var tempSrc &#x3D; this._getImgSrcFromBgImg(bgImg, imgFilter);</span><br><span class="line">        if (tempSrc &amp;&amp; this._isImg(tempSrc, imgFilter)) &#123;</span><br><span class="line">          src &#x3D; tempSrc;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return src;</span><br><span class="line">    &#125;,</span><br><span class="line">    _isImg: function (src, imgFilter) &#123;</span><br><span class="line">      for (var i &#x3D; 0, len &#x3D; imgFilter.length; i &lt; len; i++) &#123;</span><br><span class="line">        if (imgFilter[i].test(src)) &#123;</span><br><span class="line">          return true;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;,</span><br><span class="line">    traverse(e) &#123;</span><br><span class="line">      var _this &#x3D; this, tName &#x3D; e.tagName;</span><br><span class="line">      if (&quot;SCRIPT&quot; !&#x3D;&#x3D; tName &amp;&amp; &quot;STYLE&quot; !&#x3D;&#x3D; tName &amp;&amp; &quot;META&quot; !&#x3D;&#x3D; tName &amp;&amp; &quot;HEAD&quot; !&#x3D;&#x3D; tName) &#123;</span><br><span class="line">        var el &#x3D; this.getImgSrcFromDom(e)</span><br><span class="line">        if (el &amp;&amp; !imgs.includes(el))</span><br><span class="line">          imgs.push(el)</span><br><span class="line">        var len &#x3D; e.children ? e.children.length : 0;</span><br><span class="line">        if (len &gt; 0)</span><br><span class="line">          for (var child &#x3D; e.children, _len &#x3D; len - 1; _len &gt;&#x3D; 0; _len--)</span><br><span class="line">            _this.traverse(child[_len]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  getImageDomSrc.traverse(document.body);</span><br><span class="line">  window.onload&#x3D;function()&#123;</span><br><span class="line">  var max &#x3D; Math.max(...imgs.map(element &#x3D;&gt; &#123;</span><br><span class="line">     if (&#x2F;^(\&#x2F;\&#x2F;)&#x2F;.test(element))</span><br><span class="line">      element &#x3D; &#39;https:&#39; + element;</span><br><span class="line">    try &#123;</span><br><span class="line">      return performance.getEntriesByName(element)[0].responseEnd || 0</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      return 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ))</span><br><span class="line">  console.log(max);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">)()</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="白屏"><a href="#白屏" class="headerlink" title="白屏"></a>白屏</h2><blockquote>
<p>从输入内容回车(包括刷新,跳转等方式)后到页面开始出现第一个字符的时间</p>
</blockquote>
<p>白屏指标怎么采集呢？我们先来回顾一下前面讲过的浏览器的页面加载过程：</p>
<p>客户端发起请求 -&gt; 下载 HTML 及 JS/CSS 资源 -&gt; 解析 JS 执行 -&gt; JS 请求数据 -&gt; 客户端解析 DOM 并渲染 -&gt; 下载渲染图片-&gt; 完成渲整体染。</p>
<p>在这个过程中，<strong>客户端解析 DOM 并渲染之前的时间，都算白屏时间</strong>。</p>
<p>所以，白屏时间的采集思路如下：白屏时间 = 页面开始展示时间点 - 开始请求时间点。</p>
<p>如果你是借助浏览器的 Performance API 工具来采集，那么可以使用公式：白屏时间 FP = domLoading - navigationStart。</p>
<p>这是浏览器页面加载过程，如果放在 App场景下，就不太一样了，App下的页面加载过程：</p>
<p>初始化 WebView -&gt; 客户端发起请求 -&gt; 下载 HTML 及 JS/CSS 资源 -&gt; 解析 JS 执行 -&gt; JS 请求数据 -&gt; 服务端处理并返回数据 -&gt; 客户端解析 DOM 并渲染 -&gt; 下载渲染图片 -&gt; 完成整体渲染。</p>
<p>App下的白屏时间，多了启动浏览器内核，也就是 Webview 初始化的时间。这个时间必须通过手动采集的方式来获得，而且因为线上线下时间差别不大，线下采集即可。具体来说，在 App 测试版本中，程序在 App 创建 WebView 时打一个点，然后在开始建立网络连接打一个点，这两个点的时间差就是 Webview 初始化的时间。</p>
<h2 id="卡顿-FPS"><a href="#卡顿-FPS" class="headerlink" title="卡顿(FPS)"></a>卡顿(FPS)</h2><p>在浏览器上，我们没办法拿到单帧渲染耗时的接口，所以这时候，只能拿 FPS 来计算，只要 FPS 保持稳定，且值比较低，就没问题。它的标准是多少呢？<br><strong>连续3帧不低于20FPS，且保持恒定</strong></p>
<p>以 H5 为例，H5 场景下获取 FPS 方案如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">var fps_compatibility&#x3D; function () &#123;</span><br><span class="line">    return (</span><br><span class="line">        window.requestAnimationFrame ||</span><br><span class="line">        window.webkitRequestAnimationFrame ||</span><br><span class="line">        function (callback) &#123;</span><br><span class="line">            window.setTimeout(callback, 1000 &#x2F; 60);</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;();</span><br><span class="line">var fps_config&#x3D;&#123;</span><br><span class="line">  lastTime:performance.now(),</span><br><span class="line">  lastFameTime : performance.now(),</span><br><span class="line">  frame:0</span><br><span class="line">&#125;</span><br><span class="line">var fps_loop &#x3D; function() &#123;</span><br><span class="line">    var _first &#x3D;  performance.now(),_diff &#x3D; (_first - fps_config.lastFameTime);</span><br><span class="line">    fps_config.lastFameTime &#x3D; _first;</span><br><span class="line">    var fps &#x3D; Math.round(1000&#x2F;_diff);</span><br><span class="line">    fps_config.frame++;</span><br><span class="line">    if (_first &gt; 1000 + fps_config.lastTime) &#123;</span><br><span class="line">        var fps &#x3D; Math.round( ( fps_config.frame * 1000 ) &#x2F; ( _first - fps_config.lastTime ) );</span><br><span class="line">        console.log(&#96;time: $&#123;new Date()&#125; fps is：&#96;, fps);</span><br><span class="line">        fps_config.frame &#x3D; 0;    </span><br><span class="line">        fps_config.lastTime &#x3D; _first ;    </span><br><span class="line">    &#125;;           </span><br><span class="line">    fps_compatibility(fps_loop);   </span><br><span class="line">&#125;</span><br><span class="line">fps_loop();</span><br><span class="line">function isBlocking(fpsList, below&#x3D;20, last&#x3D;3) &#123;</span><br><span class="line">  var count &#x3D; 0</span><br><span class="line">  for(var i &#x3D; 0; i &lt; fpsList.length; i++) &#123;</span><br><span class="line">    if (fpsList[i] &amp;&amp; fpsList[i] &lt; below) &#123;</span><br><span class="line">      count++;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      count &#x3D; 0</span><br><span class="line">    &#125;</span><br><span class="line">    if (count &gt;&#x3D; last) &#123;</span><br><span class="line">      return true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用 requestAnimationFrame 在一秒内执行 60 次（在不卡顿的情况下）这一点，假设页面加载用时 X ms，这期间 requestAnimationFrame 执行了 N 次，则帧率为1000* N/X，也就是FPS。</p>
<p>由于用户客户端差异很大，我们要考虑兼容性，在这里我们定义 fps_compatibility 表示兼容性方面的处理，在浏览器不支持 requestAnimationFrame 时，利用 setTimeout 来模拟实现，在 fps_loop 里面完成 FPS 的计算，最终通过遍历 fpsList 来判断是否连续三次 fps 小于20。</p>
<p>如果连续判断 3次 FPS 都小于20，就认为是卡顿。</p>
<p>那么，在 App 侧，怎么采集卡顿指标呢？</p>
<p>App 侧可以拿到单帧渲染时长，直接让 App 取到单帧渲染时长，如果在 Android 环境下，可以直接取到单帧渲染时长</p>
<p>为什么会出现 App 白屏时间过长或卡顿问题呢？</p>
<p>一般 WebView 初始化慢、DNS 解析慢、视图树过于复杂和主线程被阻塞等都会导致问题出现，但很多情况下白屏时间和卡顿都和网络环境有关。为了保证页面顺畅，我们需要做一些服务降级处理，比如对电商网站来说，高清图可以用文本代替，仅展示购买按钮和价格等核心内容。而要实现这个功能，就必须先做好网络环境采集。</p>
<h2 id="网络环境采集"><a href="#网络环境采集" class="headerlink" title="网络环境采集"></a>网络环境采集</h2><p>为什么不能直接拿到网络环境数据呢？如果在 App 内， 我们可以通过 App 提供的接口获取到网络情况，但在端外（App 外部环境，比如微信里面的页面，或者PC站、手机浏览器下的页面）我们就没法直接拿到当前网络情况了。这时怎么办呢？</p>
<p>一个做法是拿到两张不同尺寸图片的加载时间，通过计算结果来判定当前网络环境。</p>
<p>具体来说，我们在每次页面加载时，通过客户端向服务端发送图片请求，比如，请求一张 1<em>1 像素的图片和一张 3</em>3 像素的图片，然后在图片请求之初打一个时间点，在图片 onLoad 完成后打一个时间点，两个时间点之差，就是图片的加载时间。</p>
<p>接着，我们用文件体积除以加载时间，就能得出两张图片的加载速度，然后把两张图片的加载速度求平均值，这个结果就可以当作网络速度了。</p>
<p>因为每个单页面启动时，都会做一次网速采集，得到一个网络速度，我们可以把这些网络速度做概率分布，就能得出当前网络情况是 2G （750-1400ms）、3G （230-750ms）、4G或者WiFi（0-230ms）。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>性能优化-指标采集</p><p><a href="https://richardspace369.github.io/2021/03/10/性能优化/指标采集/">https://richardspace369.github.io/2021/03/10/性能优化/指标采集/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>richard</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-03-10</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-03-10</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/03/10/javascript/%E5%AE%9A%E5%9E%8B%E6%95%B0%E7%BB%84/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">定型数组</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/03/10/javascript/promise/"><span class="level-item">异步编程-promise</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#首屏"><span class="level-left"><span class="level-item">1</span><span class="level-item">首屏</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#手动采集办法及优缺点"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">手动采集办法及优缺点</span></span></a></li><li><a class="level is-mobile" href="#自动化采集优势及办法"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">自动化采集优势及办法</span></span></a></li><li><a class="level is-mobile" href="#服务端模板业务下的采集办法"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">服务端模板业务下的采集办法</span></span></a></li><li><a class="level is-mobile" href="#单页面（SPA）应用业务下的采集办法"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">单页面（SPA）应用业务下的采集办法</span></span></a></li></ul></li><li><a class="level is-mobile" href="#白屏"><span class="level-left"><span class="level-item">2</span><span class="level-item">白屏</span></span></a></li><li><a class="level is-mobile" href="#卡顿-FPS"><span class="level-left"><span class="level-item">3</span><span class="level-item">卡顿(FPS)</span></span></a></li><li><a class="level is-mobile" href="#网络环境采集"><span class="level-left"><span class="level-item">4</span><span class="level-item">网络环境采集</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-10T10:04:37.345Z">2021-03-10</time></p><p class="title"><a href="/2021/03/10/javascript/%E5%AE%9A%E5%9E%8B%E6%95%B0%E7%BB%84/">定型数组</a></p><p class="categories"><a href="/categories/javascript/">javascript</a> / <a href="/categories/javascript/%E5%AE%9A%E5%9E%8B%E6%95%B0%E7%BB%84/">定型数组</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-10T10:04:37.345Z">2021-03-10</time></p><p class="title"><a href="/2021/03/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%8C%87%E6%A0%87%E9%87%87%E9%9B%86/">性能优化-指标采集</a></p><p class="categories"><a href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-10T10:04:37.345Z">2021-03-10</time></p><p class="title"><a href="/2021/03/10/javascript/promise/">异步编程-promise</a></p><p class="categories"><a href="/categories/javascript/">javascript</a> / <a href="/categories/javascript/promise/">promise</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-10T10:04:37.345Z">2021-03-10</time></p><p class="title"><a href="/2021/03/10/javascript/array/">js中的array</a></p><p class="categories"><a href="/categories/javascript/">javascript</a> / <a href="/categories/javascript/%E6%95%B0%E7%BB%84/">数组</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-10T10:04:37.345Z">2021-03-10</time></p><p class="title"><a href="/2021/03/10/%E5%B7%A5%E7%A8%8B%E5%8C%96/npm,yarn%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6/">前端工程化-npm和Yarn安装机制</a></p><p class="categories"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">RichardSpace</a><p class="is-size-7"><span>&copy; 2021 richard</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/RichardSpace369"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>