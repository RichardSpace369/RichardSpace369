<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>js中的array - richardSpace</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="richardSpace"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="richardSpace"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="js中的数据是一种特殊的对象，它具有如下方法..."><meta property="og:type" content="blog"><meta property="og:title" content="js中的array"><meta property="og:url" content="https://richardspace369.github.io/2021/03/09/javascript/array/"><meta property="og:site_name" content="richardSpace"><meta property="og:description" content="js中的数据是一种特殊的对象，它具有如下方法..."><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://richardspace369.github.io/img/og_image.png"><meta property="article:published_time" content="2021-03-09T10:27:49.375Z"><meta property="article:modified_time" content="2021-03-09T10:27:49.375Z"><meta property="article:author" content="richard"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://richardspace369.github.io/2021/03/09/javascript/array/"},"headline":"richardSpace","image":["https://richardspace369.github.io/img/og_image.png"],"datePublished":"2021-03-09T10:27:49.375Z","dateModified":"2021-03-09T10:27:49.375Z","author":{"@type":"Person","name":"richard"},"description":"js中的数据是一种特殊的对象，它具有如下方法..."}</script><link rel="canonical" href="https://richardspace369.github.io/2021/03/09/javascript/array/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">RichardSpace</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/RichardSpace369"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-09T10:27:49.375Z" title="3/9/2021, 10:27:49 AM">2021-03-09</time>发表</span><span class="level-item"><time dateTime="2021-03-09T10:27:49.375Z" title="3/9/2021, 10:27:49 AM">2021-03-09</time>更新</span><span class="level-item"> richard </span><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a><span> / </span><a class="link-muted" href="/categories/javascript/%E6%95%B0%E7%BB%84/">数组</a></span><span class="level-item">1 小时读完 (大约7342个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">js中的array</h1><div class="content"><h2 id="理解数组"><a href="#理解数组" class="headerlink" title="理解数组"></a>理解数组</h2><blockquote>
<p>数组（Array）是<strong>有序的</strong>元素序列。若将有限个<strong>类型相同</strong>的变量的集合命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。用于区分数组的各个元素的数字编号称为下标</p>
</blockquote>
<p>上面是百度百科对数组的解释：我们可以看出<strong>数组在内存中是一段连续的同类型的数据空间</strong></p>
<h3 id="js中数组的表现了？"><a href="#js中数组的表现了？" class="headerlink" title="js中数组的表现了？"></a>js中数组的表现了？</h3><p>我们先看MDN 对数组的定义</p>
<blockquote>
<p>数组是一种类列表对象，它的原型中提供了遍历和修改元素的相关操作。JavaScript 数组的长度和元素类型都是非固定的。因为数组的长度可随时改变，并且其数据在内存中也可以不连续，所以 JavaScript 数组不一定是密集型的，这取决于它的使用方式</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr&#x3D;[1,2,3]</span><br><span class="line">arr.name&#x3D;&quot;数组&quot;</span><br><span class="line">console.log(arr.name)&#x2F;&#x2F;&quot;数组&quot;</span><br></pre></td></tr></table></figure>
<p>从上面的代码我们可以看出来并不满足上面数组的定义。 其实这是因为<strong>js中的数组是一个特殊的对象</strong></p>
<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>在js中创建一个数组一共有二种方法，分别是</p>
<ol>
<li>字面量创建</li>
<li>Array构造函数创建和new Array()</li>
</ol>
<p>当我们使用Array构造函数创建数组的时候，<strong>当我们传入的参数只有一个数值(n)的时候，代表需要创建长度为n的数组，如果传入的参数是一系列参数，代表创建长度为参数的个数，且只包含这些参数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new Arrray(5)&#x2F;&#x2F;[empty × 5]</span><br><span class="line">new Array(5,1)&#x2F;&#x2F;[5,1]</span><br><span class="line">new Array(&quot;a&quot;)&#x2F;&#x2F;[&quot;a&quot;]</span><br><span class="line">console.log(new Array(&#123; length: 3 &#125;)); &#x2F;&#x2F;[&#123;length:3&#125;]</span><br></pre></td></tr></table></figure>
<p><strong>注意：这里有一个细节问题，就是当我们传入的参数为一个数值的时候，会带来数组空位的问题</strong></p>
<h2 id="数组构造方法"><a href="#数组构造方法" class="headerlink" title="数组构造方法"></a>数组构造方法</h2><h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h3><blockquote>
<p>Array.from() 方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。<br>它的语法如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Array.from(arrayLike[, mapFn[, thisArg]])</span><br><span class="line"></span><br><span class="line">arrayLike: 想要转换成数组的伪数组对象(包含length)或可迭代对象。</span><br><span class="line">mapFn:可选， 如果指定了该参数，新数组中的每个元素会执行该回调函数。也就是支持一个映射函数</span><br><span class="line">thisArg:可选参数，执行回调函数 mapFn 时 this 对象。 </span><br></pre></td></tr></table></figure>
<p>下面是针对他的使用案例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(Array.from(&#39;abc&#39;)); &#x2F;&#x2F;[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">console.log(Array.from(&#39;abc&#39;, (val) &#x3D;&gt; val + 2)); &#x2F;&#x2F; [&quot;a2&quot;, &quot;b2&quot;, &quot;c2&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of"></a>Array.of</h3><blockquote>
<p>Array.of() 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">console.log(Array.of(1, 2, 3)); &#x2F;&#x2F; [1, 2, 3]</span><br><span class="line">console.log(Array.of(7))&#x2F;&#x2F;[7]</span><br><span class="line">   &#x2F;&#x2F;polyfill方法</span><br><span class="line">   if (!Array.of) &#123;</span><br><span class="line">       Array.of &#x3D; function() &#123;</span><br><span class="line">           return Array.prototype.slice.call(arguments);</span><br><span class="line">       &#125;;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray"></a>Array.isArray</h3><p>如果对象是 Array ，则返回true，否则为false。</p>
<p>当检测Array实例时, Array.isArray 优于 instanceof,因为Array.isArray能检测iframes.</p>
<h2 id="关于数组的length"><a href="#关于数组的length" class="headerlink" title="关于数组的length"></a>关于数组的length</h2><blockquote>
<p>length 属性的值是一个 0 到 232-1 的整数。</p>
</blockquote>
<p>数组的长度在属性描述符里面是，可修改不可删除和遍历的</p>
<p>数组的length在使用上有一个需要注意的点，当我们进行增删数组的时候，数组长度会自动变化，当我们将Length长度变大的时候，数组元素会自动扩充，当我们改小Length的时候，会移除部分元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const a &#x3D; [];</span><br><span class="line">a.length &#x3D; 5;</span><br><span class="line">console.log(a);&#x2F;&#x2F;&lt;5 empty items&gt; </span><br><span class="line">a.length&#x3D;3</span><br><span class="line">console.log(a)&#x2F;&#x2F;[ &lt;3 empty items&gt; ]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="理解数组空位"><a href="#理解数组空位" class="headerlink" title="理解数组空位"></a>理解数组空位</h2><blockquote>
<p>数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array(3) &#x2F;&#x2F; [, , ,]</span><br></pre></td></tr></table></figure>
<p><strong>注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 in [, , ,] &#x2F;&#x2F; false</span><br><span class="line">0 in [undefined, undefined, undefined] &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p>ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。</p>
<ul>
<li>forEach(), filter(), reduce(), every() 和some()都会跳过空位。</li>
<li>map()会跳过空位，但会保留这个值</li>
<li>join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; forEach方法</span><br><span class="line">[,&#39;a&#39;].forEach((x,i) &#x3D;&gt; console.log(i)); &#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; filter方法</span><br><span class="line">[&#39;a&#39;,,&#39;b&#39;].filter(x &#x3D;&gt; true) &#x2F;&#x2F; [&#39;a&#39;,&#39;b&#39;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; every方法</span><br><span class="line">[,&#39;a&#39;].every(x &#x3D;&gt; x&#x3D;&#x3D;&#x3D;&#39;a&#39;) &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; reduce方法</span><br><span class="line">[1,,2].reduce((x,y) &#x3D;&gt; x+y) &#x2F;&#x2F; 3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; some方法</span><br><span class="line">[,&#39;a&#39;].some(x &#x3D;&gt; x !&#x3D;&#x3D; &#39;a&#39;) &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; map方法</span><br><span class="line">[,&#39;a&#39;].map(x &#x3D;&gt; 1) &#x2F;&#x2F; [,1]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; join方法</span><br><span class="line">[,&#39;a&#39;,undefined,null].join(&#39;#&#39;) &#x2F;&#x2F; &quot;#a##&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; toString方法</span><br><span class="line">[,&#39;a&#39;,undefined,null].toString() &#x2F;&#x2F; &quot;,a,,&quot;</span><br></pre></td></tr></table></figure>
ES6 则是明确将空位转为undefined。</li>
</ul>
<p>for…of循环也会遍历空位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [, ,];</span><br><span class="line">for (let i of arr) &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>
<p>entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; entries()</span><br><span class="line">[...[,&#39;a&#39;].entries()] &#x2F;&#x2F; [[0,undefined], [1,&quot;a&quot;]]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; keys()</span><br><span class="line">[...[,&#39;a&#39;].keys()] &#x2F;&#x2F; [0,1]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; values()</span><br><span class="line">[...[,&#39;a&#39;].values()] &#x2F;&#x2F; [undefined,&quot;a&quot;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; find()</span><br><span class="line">[,&#39;a&#39;].find(x &#x3D;&gt; true) &#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; findIndex()</span><br><span class="line">[,&#39;a&#39;].findIndex(x &#x3D;&gt; true) &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>

<h2 id="Array-原型上的方法"><a href="#Array-原型上的方法" class="headerlink" title="Array 原型上的方法"></a>Array 原型上的方法</h2><h3 id="修改器方法"><a href="#修改器方法" class="headerlink" title="修改器方法"></a>修改器方法</h3><h4 id="copywithin"><a href="#copywithin" class="headerlink" title="copywithin"></a>copywithin</h4><blockquote>
<p>copyWithin() 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。<br>语法如下：</p>
</blockquote>
<p>arr.copyWithin(target[, start[, end]])<br>target<br>0 为基底的索引，复制序列到该位置。如果是负数，target 将从末尾开始计算。<br>如果 target 大于等于 arr.length，将会不发生拷贝。如果 target 在 start 之后，复制的序列将被修改以符合 arr.length。</p>
<p>start<br>0 为基底的索引，开始复制元素的起始位置。如果 start 被忽略，copyWithin 将会从0开始复制。如果 start 为负，则其指定的索引位置等同于 length+start，length 为数组的长度。end 也是如此。</p>
<p>end<br>0 为基底的索引，开始复制元素的结束位置。copyWithin 将会拷贝到该位置，但不包括 end 这个位置的元素。如果 end 被忽略，copyWithin 方法将会一直复制至数组结尾（默认为 arr.length）</p>
<p>copyWithin 方法不要求其 this 值必须是一个数组对象；除此之外，copyWithin 是一个可变方法，它可以改变 this 对象本身，并且返回它，而不仅仅是它的拷贝。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5].copyWithin(-2)</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3, 1, 2]</span><br><span class="line"></span><br><span class="line">[1, 2, 3, 4, 5].copyWithin(0, 3)</span><br><span class="line">&#x2F;&#x2F; [4, 5, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">[1, 2, 3, 4, 5].copyWithin(0, 3, 4)</span><br><span class="line">&#x2F;&#x2F; [4, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">[1, 2, 3, 4, 5].copyWithin(-2, -3, -1)</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3, 3, 4]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h4><blockquote>
<p>fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。<br>语法如下</p>
</blockquote>
<p>arr.fill(value[, start[, end]])</p>
<p>value 用来填充数组元素的值。</p>
<p>start 可选 起始索引，默认值为0。</p>
<p>end 可选 终止索引，默认值为 this.length。</p>
<p>如果 start 是个负数, 则开始索引会被自动计算成为 length+start, 其中 length 是 this 对象的 length 属性值。如果 end 是个负数, 则结束索引会被自动计算成为 length+end。</p>
<p>fill 方法故意被设计成通用方法, 该方法不要求 this 是数组对象。</p>
<p>fill 方法是个可变方法, 它会改变调用它的 this 对象本身, 然后返回它, 而并不是返回一个副本。</p>
<p>当一个对象被传递给 fill方法的时候, 填充数组的是这个对象的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].fill(4);               &#x2F;&#x2F; [4, 4, 4]</span><br><span class="line">[1, 2, 3].fill(4, 1);            &#x2F;&#x2F; [1, 4, 4]</span><br><span class="line">[1, 2, 3].fill(4, 1, 2);         &#x2F;&#x2F; [1, 4, 3]</span><br><span class="line">[1, 2, 3].fill(4, 1, 1);         &#x2F;&#x2F; [1, 2, 3]</span><br><span class="line">[1, 2, 3].fill(4, 3, 3);         &#x2F;&#x2F; [1, 2, 3]</span><br><span class="line">[1, 2, 3].fill(4, -3, -2);       &#x2F;&#x2F; [4, 2, 3]</span><br><span class="line">[1, 2, 3].fill(4, NaN, NaN);     &#x2F;&#x2F; [1, 2, 3]</span><br><span class="line">[1, 2, 3].fill(4, 3, 5);         &#x2F;&#x2F; [1, 2, 3]</span><br><span class="line">Array(3).fill(4);                &#x2F;&#x2F; [4, 4, 4]</span><br><span class="line">[].fill.call(&#123; length: 3 &#125;, 4);  &#x2F;&#x2F; &#123;0: 4, 1: 4, 2: 4, length: 3&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Objects by reference.</span><br><span class="line">var arr &#x3D; Array(3).fill(&#123;&#125;) &#x2F;&#x2F; [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">&#x2F;&#x2F; 需要注意如果fill的参数为引用类型，会导致都执行都一个引用类型</span><br><span class="line">&#x2F;&#x2F; 如 arr[0] &#x3D;&#x3D;&#x3D; arr[1] 为true</span><br><span class="line">arr[0].hi &#x3D; &quot;hi&quot;; &#x2F;&#x2F; [&#123; hi: &quot;hi&quot; &#125;, &#123; hi: &quot;hi&quot; &#125;, &#123; hi: &quot;hi&quot; &#125;]</span><br></pre></td></tr></table></figure>
<h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><h4 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h4><h4 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h4><h4 id="unshift"><a href="#unshift" class="headerlink" title="unshift"></a>unshift</h4><blockquote>
<p>unshift() 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度(该方法修改原有数组)。</p>
</blockquote>
<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><blockquote>
<p>sort() 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的</p>
</blockquote>
<p>如果没有指明 compareFunction ，那么元素会按照转换为的字符串的诸个字符的Unicode位点进行排序。例如 “Banana” 会被排列到 “cherry” 之前。当数字按由小到大排序时，9 出现在 80 之前，但因为（没有指明 compareFunction），比较的数字会先被转换为字符串，所以在Unicode顺序上 “80” 要比 “9” 要靠前。</p>
<p><strong>使用映射改善排序</strong></p>
<p>compareFunction 可能需要对元素做多次映射以实现排序，尤其当 compareFunction 较为复杂，且元素较多的时候，某些 compareFunction 可能会导致很高的负载。使用 map 辅助排序将会是一个好主意。基本思想是首先将数组中的每个元素比较的实际值取出来，排序后再将数组恢复</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 需要被排序的数组</span><br><span class="line">var list &#x3D; [&#39;Delta&#39;, &#39;alpha&#39;, &#39;CHARLIE&#39;, &#39;bravo&#39;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对需要排序的数字和位置的临时存储</span><br><span class="line">var mapped &#x3D; list.map(function(el, i) &#123;</span><br><span class="line">  return &#123; index: i, value: el.toLowerCase() &#125;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 按照多个值排序数组</span><br><span class="line">mapped.sort(function(a, b) &#123;</span><br><span class="line">  return +(a.value &gt; b.value) || +(a.value &#x3D;&#x3D;&#x3D; b.value) - 1;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 根据索引得到排序的结果</span><br><span class="line">var result &#x3D; mapped.map(function(el)&#123;</span><br><span class="line">  return list[el.index];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="reverse方法"><a href="#reverse方法" class="headerlink" title="reverse方法"></a>reverse方法</h4><blockquote>
<p>reverse() 方法将数组中元素的位置颠倒，并返回该数组。数组的第一个元素会变成最后一个，数组的最后一个元素变成第一个。该方法会改变原数组。</p>
</blockquote>
<p>reverse方法是特意类化的；此方法可被 called 或 applied于类似数组对象。对象如果不包含反映一系列连续的、基于零的数值属性中的最后一个长度的属性，则该对象可能不会以任何有意义的方式运行。</p>
<p>如：颠倒类数组中的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const a &#x3D; &#123; 0: 1, 1: 2, 2: 3, length: 3 &#125;;</span><br><span class="line">Array.prototype.reverse.call(a);</span><br><span class="line">console.log(a); &#x2F;&#x2F; &#123;0: 3, 1: 2, 2: 1, length: 3&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Array-prototype-splice"><a href="#Array-prototype-splice" class="headerlink" title="Array.prototype.splice()"></a>Array.prototype.splice()</h4><blockquote>
<p>splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。<br>语法：<br>array.splice(start[, deleteCount[, item1[, item2[, …]]]])</p>
</blockquote>
<p>start​指定修改的开始位置（从0计数）。如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表示从数组末位开始的第几位（从-1计数，这意味着-n是倒数第n个元素并且等价于array.length-n）；如果负数的绝对值大于数组的长度，则表示开始位置为第0位。</p>
<p>deleteCount 可选整数，表示要移除的数组元素的个数。如果 deleteCount 大于 start 之后的元素的总数，则从 start 后面的元素都将被删除（含第 start 位）。如果 deleteCount 被省略了，或者它的值大于等于array.length - start(也就是说，如果它大于或者等于start之后的所有元素的数量)，那么start之后数组的所有元素都会被删除。如果 deleteCount 是 0 或者负数，则不移除元素。这种情况下，至少应添加一个新元素。</p>
<p>item1, item2, … 可选要添加进数组的元素,从start 位置开始。如果不指定，则 splice() 将只删除数组元素。</p>
<h3 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h3><blockquote>
<p>下面的这些方法绝对不会改变调用它们的对象的值，只会返回一个新的数组或者返回一个其它的期望值。</p>
</blockquote>
<h4 id="concat-方法"><a href="#concat-方法" class="headerlink" title="concat 方法"></a>concat 方法</h4><blockquote>
<p>concat()方法可以在现有数组全部元素基础上创建一个新数组。它首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组</p>
</blockquote>
<p>如果传入的一组参数中，包含的有数组就将数组打平展开(双重嵌套的数组不会进行此操作)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log([1, 2, 3].concat(4, [5, 6])); &#x2F;&#x2F;[1,2,3,4,5,6]</span><br><span class="line">console.log([1, 2, 3].concat(4, [5, [6]])); &#x2F;&#x2F;[1,2,3,4,5,[6]]</span><br></pre></td></tr></table></figure>

<p>concat方法不会改变this或任何作为参数提供的数组，而是返回一个浅拷贝，它包含与原始数组相结合的相同元素的副本。 原始数组的元素将复制到新数组中，如下所示：</p>
<ul>
<li>对象引用（而不是实际对象）：concat将对象引用复制到新数组中。 原始数组和新数组都引用相同的对象。 也就是说，如果引用的对象被修改，则更改对于新数组和原始数组都是可见的。 这包括也是数组的数组参数的元素。</li>
<li>数据类型如字符串，数字和布尔（不是String，Number 和 Boolean 对象）：concat将字符串和数字的值复制到新数组中。</li>
</ul>
<p><strong>注意：可以阻止打平数组</strong></p>
<p>打平数组参数的行为可以重写，方法是在参数数组上指定一个特殊的符号：Symbol.isConcatSpreadable。这个符号能够阻止 concat()打平参数数组。相反，把这个值设置为 true 可以强制打平类数组对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let colors &#x3D; [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; </span><br><span class="line">let newColors &#x3D; [&quot;black&quot;, &quot;brown&quot;]; </span><br><span class="line">let moreNewColors &#x3D; &#123; </span><br><span class="line"> [Symbol.isConcatSpreadable]: true, </span><br><span class="line"> length: 2, </span><br><span class="line"> 0: &quot;pink&quot;, </span><br><span class="line"> 1: &quot;cyan&quot; </span><br><span class="line">&#125;; </span><br><span class="line">newColors[Symbol.isConcatSpreadable] &#x3D; false; </span><br><span class="line">&#x2F;&#x2F; 强制不打平数组</span><br><span class="line">let colors2 &#x3D; colors.concat(&quot;yellow&quot;, newColors); </span><br><span class="line">&#x2F;&#x2F; 强制打平类数组对象</span><br><span class="line">let colors3 &#x3D; colors.concat(moreNewColors);</span><br></pre></td></tr></table></figure>
<h4 id="inclueds"><a href="#inclueds" class="headerlink" title="inclueds"></a>inclueds</h4><blockquote>
<p>includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。<br>语法如下：<br>arr.includes(valueToFind[, fromIndex])<br>valueToFind： 需要查找的元素值。<br>fromIndex: 从fromIndex 索引处开始查找 valueToFind。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜,如果计算出来的值还是小于0，那么整个数组都会被搜索。默认为 0。如果 fromIndex 大于等于数组的长度，则会返回 false，且该数组不会被搜索。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];</span><br><span class="line"></span><br><span class="line">arr.includes(&#39;a&#39;, -100); &#x2F;&#x2F; true</span><br><span class="line">arr.includes(&#39;b&#39;, -100); &#x2F;&#x2F; true</span><br><span class="line">arr.includes(&#39;c&#39;, -100); &#x2F;&#x2F; true</span><br><span class="line">arr.includes(&#39;a&#39;, -2); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
<h4 id="JOIn方法"><a href="#JOIn方法" class="headerlink" title="JOIn方法"></a>JOIn方法</h4><blockquote>
<p>join() 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ar a &#x3D; [&#39;Wind&#39;, &#39;Rain&#39;, &#39;Fire&#39;];</span><br><span class="line">var myVar1 &#x3D; a.join();      &#x2F;&#x2F; myVar1的值变为&quot;Wind,Rain,Fire&quot;</span><br><span class="line">var myVar2 &#x3D; a.join(&#39;, &#39;);  &#x2F;&#x2F; myVar2的值变为&quot;Wind, Rain, Fire&quot;</span><br><span class="line">var myVar3 &#x3D; a.join(&#39; + &#39;); &#x2F;&#x2F; myVar3的值变为&quot;Wind + Rain + Fire&quot;</span><br><span class="line">var myVar4 &#x3D; a.join(&#39;&#39;);    &#x2F;&#x2F; myVar4的值变为&quot;WindRainFire&quot;</span><br></pre></td></tr></table></figure>
<p><strong>如果数组中某一项是 null 或 undefined，则在 join()、toLocaleString()、toString()和 valueOf()返回的结果中会以空字符串表示</strong></p>
<h4 id="slice-方法"><a href="#slice-方法" class="headerlink" title="slice 方法"></a>slice 方法</h4><blockquote>
<p>slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。</p>
</blockquote>
<p>语法</p>
<p>arr.slice([begin[, end]])</p>
<p>begin 可选<br>提取起始处的索引（从 0 开始），从该索引开始提取原数组元素。<br>如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取，slice(-2) 表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。<br>如果省略 begin，则 slice 从索引 0 开始。<br>如果 begin 超出原数组的索引范围，则会返回空数组。</p>
<p>end 可选<br>提取终止处的索引（从 0 开始），在该索引处结束提取原数组元素。slice 会提取原数组中索引从 begin 到 end 的所有元素（包含 begin，但不包含 end）。<br>slice(1,4) 会提取原数组中从第二个元素开始一直到第四个元素的所有元素 （索引为 1, 2, 3的元素）。<br>如果该参数为负数， 则它表示在原数组中的倒数第几个元素结束抽取。 slice(-2,-1) 表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。<br>如果 end 被省略，则 slice 会一直提取到原数组末尾。<br>如果 end 大于数组的长度，slice 也会一直提取到原数组末尾。</p>
<h4 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h4><blockquote>
<p>indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</p>
</blockquote>
<p>语法如下</p>
<p>arr.indexOf(searchElement[, fromIndex])</p>
<p>fromIndex 可选<br>开始查找的位置。如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回-1。如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消，即-1表示从最后一个元素开始查找，-2表示从倒数第二个元素开始查找 ，以此类推。 注意：如果参数中提供的索引值是一个负值，并不改变其查找顺序，查找顺序仍然是从前向后查询数组。如果抵消后的索引值仍小于0，则整个数组都将会被查询。其默认值为0.</p>
<h4 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h4><blockquote>
<p>lastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。<br>语法:</p>
</blockquote>
<p>arr.lastIndexOf(searchElement[, fromIndex])</p>
<p>fromIndex 可选</p>
<p>从此位置开始逆向查找。默认为数组的长度减 1(arr.length - 1)，即整个数组都被查找。如果该值大于或等于数组的长度，则整个数组会被查找。如果为负值，将其视为从数组末尾向前的偏移。即使该值为负，数组仍然会被从后向前查找。如果该值为负时，其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。</p>
<h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><p>在下面的众多遍历方法中，有很多方法都需要指定一个回调函数作为参数。在每一个数组元素都分别执行完回调函数之前，数组的length属性会被缓存在某个地方，所以，如果你在回调函数中为当前数组添加了新的元素，那么那些新添加的元素是不会被遍历到的。此外，如果在回调函数中对当前数组进行了其它修改，比如改变某个元素的值或者删掉某个元素，那么随后的遍历操作可能会受到未预期的影响</p>
<h4 id="entries，keys-values-方法"><a href="#entries，keys-values-方法" class="headerlink" title="entries，keys,values 方法"></a>entries，keys,values 方法</h4><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><blockquote>
<p>forEach() 方法对数组的每个元素执行一次给定的函数。</p>
</blockquote>
<p>语法：<br>arr.forEach(callback(currentValue [, index [, array]])[, thisArg])</p>
<p>callback：为数组中每个元素执行的函数，该函数接收一至三个参数：</p>
<pre><code>currentValue:数组中正在处理的当前元素。

index: 可选数组中正在处理的当前元素的索引。

array 可选forEach() 方法正在操作的数组。
</code></pre>
<p>thisArg 可选:可选参数。当执行回调函数 callback 时，用作 this 的值。如果 thisArg 参数有值，则每次 callback 函数被调用时，this 都会指向 thisArg 参数。如果省略了 thisArg 参数，或者其值为 null 或 undefined，this 则指向全局对象。按照函数观察到 this 的常用规则，callback 函数最终可观察到 this 值，注意：如果使用箭头函数表达式来传入函数参数， thisArg 参数会被忽略，因为箭头函数在词法上绑定了 this 值。</p>
<p>注意：<strong>除了抛出异常以外，没有办法中止或跳出 forEach() 循环。如果你需要中止或跳出循环，forEach() 方法不是应当使用的工具。</strong></p>
<p>forEach() 遍历的范围在第一次调用 callback 前就会确定。调用 forEach 后添加到数组中的项不会被 callback 访问到。如果已经存在的值被改变，则传递给 callback 的值是 forEach() 遍历到他们那一刻的值。已删除的项不会被遍历到。如果已访问的元素在迭代时被删除了（例如使用 shift()），之后的元素将被跳过</p>
<p>使用forEach需要注意以下几点</p>
<ol>
<li>使用forEach遍历包含空位的数组(会跳过空位)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const arraySparse &#x3D; [1, 3, , 7];</span><br><span class="line">let numCallbackRuns &#x3D; 0;</span><br><span class="line"></span><br><span class="line">arraySparse.forEach(function(element, index) &#123;</span><br><span class="line">	console.log(element, index); &#x2F;&#x2F; index还是正常的哦</span><br><span class="line">	numCallbackRuns++;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&#39;numCallbackRuns: &#39;, numCallbackRuns);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1 0</span><br><span class="line">&#x2F;&#x2F; 3 1</span><br><span class="line">&#x2F;&#x2F; 7 3</span><br><span class="line">&#x2F;&#x2F; numCallbackRuns: 3</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>在遍历的时候操作了原数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 移除一个元素</span><br><span class="line">var words &#x3D; [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;four&#39;];</span><br><span class="line">words.forEach(function(word) &#123;</span><br><span class="line">  console.log(word);</span><br><span class="line">  if (word &#x3D;&#x3D;&#x3D; &#39;two&#39;) &#123;</span><br><span class="line">    words.shift();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; one</span><br><span class="line">&#x2F;&#x2F; two</span><br><span class="line">&#x2F;&#x2F; four</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 新增一个元素(并不会导致多遍历一次)</span><br><span class="line"></span><br><span class="line">var words &#x3D; [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;four&#39;];</span><br><span class="line">words.forEach(function(word, index) &#123;</span><br><span class="line">	console.log(word);</span><br><span class="line">	if (word &#x3D;&#x3D;&#x3D; &#39;two&#39;) &#123;</span><br><span class="line">		words.push(1231);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; one;</span><br><span class="line">&#x2F;&#x2F; two;</span><br><span class="line">&#x2F;&#x2F; three;</span><br><span class="line">&#x2F;&#x2F; fou;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="every-方法"><a href="#every-方法" class="headerlink" title="every 方法"></a>every 方法</h4><blockquote>
<p>every() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。</p>
</blockquote>
<p><strong>若收到一个空数组，此方法在一切情况下都会返回 true。</strong></p>
<p>语法：<br>arr.every(callback(element[, index[, array]])[, thisArg])</p>
<p>实现 every Polyfill</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.myEvery &#x3D; function(fn, context) &#123;</span><br><span class="line">				if (typeof callback !&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">					throw Error(&#39;错误&#39;);</span><br><span class="line">				&#125;</span><br><span class="line">				let passed &#x3D; true;</span><br><span class="line">				for (let i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">					&#x2F;&#x2F; 判断这个属性是否在对象上</span><br><span class="line">					if (Object.prototype.hasOwnProperty.call(this, i)) &#123;</span><br><span class="line">						if (!passed) &#123;</span><br><span class="line">							break;</span><br><span class="line">						&#125;</span><br><span class="line">						passed &#x3D; !!callback.call(context, this[i], i, this);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				return passed;</span><br><span class="line">			&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><blockquote>
<p>map() 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。</p>
</blockquote>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var new_array &#x3D; arr.map(function callback(currentValue[, index[, array]]) &#123;</span><br><span class="line"> &#x2F;&#x2F; Return element for new_array </span><br><span class="line">&#125;[, thisArg])</span><br></pre></td></tr></table></figure>
<p>map 方法处理数组元素的范围是在 callback 方法第一次调用之前就已经确定了。调用map方法之后追加的数组元素不会被callback访问。如果存在的数组元素改变了，那么传给callback的值是map访问该元素时的值。在map函数调用后但在访问该元素前，该元素被删除的话，则无法被访问到。</p>
<p>实现Map Polyfill</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.myMap &#x3D; function(callback, context) &#123;</span><br><span class="line">				if (typeof callback !&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">					throw Error(&#39;错误&#39;);</span><br><span class="line">				&#125;</span><br><span class="line">				const result &#x3D; [];</span><br><span class="line">				const len &#x3D; this.length;</span><br><span class="line">				for (let i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">					&#x2F;&#x2F; 判断这个属性是否在对象上</span><br><span class="line">					if (Object.prototype.hasOwnProperty.call(this, i)) &#123;</span><br><span class="line">						&#x2F;&#x2F; 使用call 的原因主要是可能改变context</span><br><span class="line">						result.push(callback.call(context, this[i], i, this));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				return result;</span><br><span class="line">			&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h4><blockquote>
<p>some() 方法测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。</p>
</blockquote>
<p><strong>如果用一个空数组进行测试，在任何情况下它返回的都是false。</strong></p>
<p>语法：<br>arr.some(callback(element[, index[, array]])[, thisArg])</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> Array.prototype.mysome &#x3D; function(fn, context) &#123;</span><br><span class="line">	if (typeof callback !&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">		throw Error(&#39;错误&#39;);</span><br><span class="line">	&#125;</span><br><span class="line">	let passed &#x3D; false;</span><br><span class="line">	for (let i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">		&#x2F;&#x2F; 判断这个属性是否在对象上</span><br><span class="line">		if (Object.prototype.hasOwnProperty.call(this, i)) &#123;</span><br><span class="line">			if (passed) &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			passed &#x3D; !!callback.call(context, this[i], i, this);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return passed;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><blockquote>
<p>filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 </p>
</blockquote>
<p>语法：<br>var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])</p>
<h4 id="find-和-findIndex"><a href="#find-和-findIndex" class="headerlink" title="find 和 findIndex()"></a>find 和 findIndex()</h4><blockquote>
<p>find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。</p>
</blockquote>
<blockquote>
<p>findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。</p>
</blockquote>
<p>语法：<br>arr.find(callback(element[, index[, array]])[, thisArg])</p>
<p>在第一次调用 callback函数时会确定元素的索引范围，因此在 find方法开始执行之后添加到数组的新元素将不会被 callback函数访问到。如果数组中一个尚未被callback函数访问到的元素的值被callback函数所改变，那么当callback函数访问到它时，它的值是将是根据它在数组中的索引所访问到的当前值。被删除的元素仍旧会被访问到，但是其值已经是undefined了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line">a.find((element) &#x3D;&gt; &#123;</span><br><span class="line">	a.push(6);</span><br><span class="line">	console.log(element);&#x2F;&#x2F; 1 2 3 4 5</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="reduce和reduceRight"><a href="#reduce和reduceRight" class="headerlink" title="reduce和reduceRight"></a>reduce和reduceRight</h4><blockquote>
<p>reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。<br>语法<br>arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</p>
</blockquote>
<p>callback: 执行数组中每个值 (如果没有提供 initialValue则第一个值除外)的函数，包含四个参数：<br>    accumulator: 累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue（见于下方）。<br>    currentValue: 数组中正在处理的元素。<br>    index 可选 数组中正在处理的当前元素的索引。 如果提供了initialValue，则起始索引号为0，否则从索引1起始。<br>    array 可选 调用reduce()的数组<br>initialValue可选 作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。</p>
<p>回调函数第一次执行时，accumulator 和currentValue的取值有两种情况：如果调用reduce()时提供了initialValue，accumulator取值为initialValue，currentValue取数组中的第一个值；如果没有提供 initialValue，那么accumulator取数组中的第一个值，currentValue取数组中的第二个值。</p>
<p>注意：如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始。</p>
<p>如果数组为空且没有提供initialValue，会抛出TypeError 。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。</p>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><h4 id="flat"><a href="#flat" class="headerlink" title="flat"></a>flat</h4><blockquote>
<p>flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。<br>指定要提取嵌套数组的结构深度，默认值为 1。</p>
</blockquote>
<ol>
<li>flat() 方法会移除数组中的空项:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr4 &#x3D; [1, 2, , 4, 5];</span><br><span class="line">arr4.flat();</span><br><span class="line">&#x2F;&#x2F; [1, 2, 4, 5]</span><br></pre></td></tr></table></figure></li>
</ol>
<p>需要思考flat的各种替代方案<br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat">参考链接</a></p>
<h2 id="数组转为其他类型"><a href="#数组转为其他类型" class="headerlink" title="数组转为其他类型"></a>数组转为其他类型</h2><ol>
<li>数组转boolean(永远转为true)</li>
<li>数组转字符串(先调用valueof再调用toString)</li>
<li>数组转Number(先调用valueOf 再调用toString)</li>
</ol>
<h2 id="知识拓展"><a href="#知识拓展" class="headerlink" title="知识拓展"></a>知识拓展</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.netinbag.com/cn/internet/what-is-an-associative-array.html">理解什么是关联数组</a></li>
</ol>
<h2 id="深入理解数组sort方法"><a href="#深入理解数组sort方法" class="headerlink" title="深入理解数组sort方法"></a>深入理解数组sort方法</h2><h3 id="sort-方法的底层实现"><a href="#sort-方法的底层实现" class="headerlink" title="sort 方法的底层实现"></a>sort 方法的底层实现</h3><p>如果要排序的元素个数是 n 的时候，那么就会有以下几种情况：</p>
<ol>
<li>当 n&lt;=10 时，采用插入排序；</li>
<li>当 n&gt;10 时，采用三路快速排序；</li>
<li>10&lt;n &lt;= 1000，采用中位数作为哨兵元素；</li>
<li>n&gt;1000，每隔 200~215 个元素挑出一个元素，放到一个新数组中，然后对它排序，找到中间位置的数，以此作为中位数。</li>
</ol>
<h4 id="1-为什么元素个数少的时候要采用插入排序？"><a href="#1-为什么元素个数少的时候要采用插入排序？" class="headerlink" title="1. 为什么元素个数少的时候要采用插入排序？"></a>1. 为什么元素个数少的时候要采用插入排序？</h4><p>虽然插入排序理论上是平均时间复杂度为 O(n^2) 的算法，快速排序是一个平均 O(nlogn) 级别的算法。但是别忘了，这只是理论上平均的时间复杂度估算，但是它们也有最好的时间复杂度情况，而插入排序在最好的情况下时间复杂度是 O(n)。</p>
<p>在实际情况中两者的算法复杂度前面都会有一个系数，当 n 足够小的时候，快速排序 nlogn 的优势会越来越小。倘若插入排序的 n 足够小，那么就会超过快排。而事实上正是如此，插入排序经过优化以后，对于小数据集的排序会有非常优越的性能，很多时候甚至会超过快排。因此，对于很小的数据量，应用插入排序是一个非常不错的选择。</p>
<h4 id="2-为什么要花这么大的力气选择哨兵元素？"><a href="#2-为什么要花这么大的力气选择哨兵元素？" class="headerlink" title="2. 为什么要花这么大的力气选择哨兵元素？"></a>2. 为什么要花这么大的力气选择哨兵元素？</h4><p>因为快速排序的性能瓶颈在于递归的深度，最坏的情况是每次的哨兵都是最小元素或者最大元素，那么进行 partition（一边是小于哨兵的元素，另一边是大于哨兵的元素）时，就会有一边是空的。如果这么排下去，递归的层数就达到了 n , 而每一层的复杂度是 O(n)，因此快排这时候会退化成 O(n^2) 级别。</p>
<p>这种情况是要尽力避免的，那么如何来避免？就是让哨兵元素尽可能地处于数组的中间位置，让最大或者最小的情况尽可能少。这时候，你就能理解 V8 里面所做的各种优化了。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>js中的array</p><p><a href="https://richardspace369.github.io/2021/03/09/javascript/array/">https://richardspace369.github.io/2021/03/09/javascript/array/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>richard</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-03-09</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-03-09</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/03/09/javascript/promise/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">异步编程-promise</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/03/09/data/%E7%9F%A9%E9%98%B5/"><span class="level-item">矩阵</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#理解数组"><span class="level-left"><span class="level-item">1</span><span class="level-item">理解数组</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#js中数组的表现了？"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">js中数组的表现了？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#创建数组"><span class="level-left"><span class="level-item">2</span><span class="level-item">创建数组</span></span></a></li><li><a class="level is-mobile" href="#数组构造方法"><span class="level-left"><span class="level-item">3</span><span class="level-item">数组构造方法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Array-from"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">Array.from</span></span></a></li><li><a class="level is-mobile" href="#Array-of"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">Array.of</span></span></a></li><li><a class="level is-mobile" href="#Array-isArray"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">Array.isArray</span></span></a></li></ul></li><li><a class="level is-mobile" href="#关于数组的length"><span class="level-left"><span class="level-item">4</span><span class="level-item">关于数组的length</span></span></a></li><li><a class="level is-mobile" href="#理解数组空位"><span class="level-left"><span class="level-item">5</span><span class="level-item">理解数组空位</span></span></a></li><li><a class="level is-mobile" href="#Array-原型上的方法"><span class="level-left"><span class="level-item">6</span><span class="level-item">Array 原型上的方法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#修改器方法"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">修改器方法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#copywithin"><span class="level-left"><span class="level-item">6.1.1</span><span class="level-item">copywithin</span></span></a></li><li><a class="level is-mobile" href="#fill"><span class="level-left"><span class="level-item">6.1.2</span><span class="level-item">fill</span></span></a></li><li><a class="level is-mobile" href="#push"><span class="level-left"><span class="level-item">6.1.3</span><span class="level-item">push</span></span></a></li><li><a class="level is-mobile" href="#pop"><span class="level-left"><span class="level-item">6.1.4</span><span class="level-item">pop</span></span></a></li><li><a class="level is-mobile" href="#shift"><span class="level-left"><span class="level-item">6.1.5</span><span class="level-item">shift</span></span></a></li><li><a class="level is-mobile" href="#unshift"><span class="level-left"><span class="level-item">6.1.6</span><span class="level-item">unshift</span></span></a></li><li><a class="level is-mobile" href="#sort"><span class="level-left"><span class="level-item">6.1.7</span><span class="level-item">sort</span></span></a></li><li><a class="level is-mobile" href="#reverse方法"><span class="level-left"><span class="level-item">6.1.8</span><span class="level-item">reverse方法</span></span></a></li><li><a class="level is-mobile" href="#Array-prototype-splice"><span class="level-left"><span class="level-item">6.1.9</span><span class="level-item">Array.prototype.splice()</span></span></a></li></ul></li><li><a class="level is-mobile" href="#访问方法"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">访问方法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#concat-方法"><span class="level-left"><span class="level-item">6.2.1</span><span class="level-item">concat 方法</span></span></a></li><li><a class="level is-mobile" href="#inclueds"><span class="level-left"><span class="level-item">6.2.2</span><span class="level-item">inclueds</span></span></a></li><li><a class="level is-mobile" href="#JOIn方法"><span class="level-left"><span class="level-item">6.2.3</span><span class="level-item">JOIn方法</span></span></a></li><li><a class="level is-mobile" href="#slice-方法"><span class="level-left"><span class="level-item">6.2.4</span><span class="level-item">slice 方法</span></span></a></li><li><a class="level is-mobile" href="#indexOf"><span class="level-left"><span class="level-item">6.2.5</span><span class="level-item">indexOf</span></span></a></li><li><a class="level is-mobile" href="#lastIndexOf"><span class="level-left"><span class="level-item">6.2.6</span><span class="level-item">lastIndexOf</span></span></a></li></ul></li><li><a class="level is-mobile" href="#迭代方法"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">迭代方法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#entries，keys-values-方法"><span class="level-left"><span class="level-item">6.3.1</span><span class="level-item">entries，keys,values 方法</span></span></a></li><li><a class="level is-mobile" href="#forEach"><span class="level-left"><span class="level-item">6.3.2</span><span class="level-item">forEach</span></span></a></li><li><a class="level is-mobile" href="#every-方法"><span class="level-left"><span class="level-item">6.3.3</span><span class="level-item">every 方法</span></span></a></li><li><a class="level is-mobile" href="#map"><span class="level-left"><span class="level-item">6.3.4</span><span class="level-item">map()</span></span></a></li><li><a class="level is-mobile" href="#some"><span class="level-left"><span class="level-item">6.3.5</span><span class="level-item">some()</span></span></a></li><li><a class="level is-mobile" href="#filter"><span class="level-left"><span class="level-item">6.3.6</span><span class="level-item">filter</span></span></a></li><li><a class="level is-mobile" href="#find-和-findIndex"><span class="level-left"><span class="level-item">6.3.7</span><span class="level-item">find 和 findIndex()</span></span></a></li><li><a class="level is-mobile" href="#reduce和reduceRight"><span class="level-left"><span class="level-item">6.3.8</span><span class="level-item">reduce和reduceRight</span></span></a></li></ul></li><li><a class="level is-mobile" href="#其他方法"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">其他方法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#flat"><span class="level-left"><span class="level-item">6.4.1</span><span class="level-item">flat</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#数组转为其他类型"><span class="level-left"><span class="level-item">7</span><span class="level-item">数组转为其他类型</span></span></a></li><li><a class="level is-mobile" href="#知识拓展"><span class="level-left"><span class="level-item">8</span><span class="level-item">知识拓展</span></span></a></li><li><a class="level is-mobile" href="#深入理解数组sort方法"><span class="level-left"><span class="level-item">9</span><span class="level-item">深入理解数组sort方法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#sort-方法的底层实现"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">sort 方法的底层实现</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-为什么元素个数少的时候要采用插入排序？"><span class="level-left"><span class="level-item">9.1.1</span><span class="level-item">1. 为什么元素个数少的时候要采用插入排序？</span></span></a></li><li><a class="level is-mobile" href="#2-为什么要花这么大的力气选择哨兵元素？"><span class="level-left"><span class="level-item">9.1.2</span><span class="level-item">2. 为什么要花这么大的力气选择哨兵元素？</span></span></a></li></ul></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-09T10:27:49.375Z">2021-03-09</time></p><p class="title"><a href="/2021/03/09/javascript/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8/">客户端存储</a></p><p class="categories"><a href="/categories/javascript/">javascript</a> / <a href="/categories/javascript/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8/">客户端存储</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-09T10:27:49.375Z">2021-03-09</time></p><p class="title"><a href="/2021/03/09/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%8C%87%E6%A0%87%E9%87%87%E9%9B%86/">性能优化-指标采集</a></p><p class="categories"><a href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-09T10:27:49.375Z">2021-03-09</time></p><p class="title"><a href="/2021/03/09/javascript/promise/">异步编程-promise</a></p><p class="categories"><a href="/categories/javascript/">javascript</a> / <a href="/categories/javascript/promise/">promise</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-09T10:27:49.375Z">2021-03-09</time></p><p class="title"><a href="/2021/03/09/javascript/array/">js中的array</a></p><p class="categories"><a href="/categories/javascript/">javascript</a> / <a href="/categories/javascript/%E6%95%B0%E7%BB%84/">数组</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-09T10:27:49.375Z">2021-03-09</time></p><p class="title"><a href="/2021/03/09/data/%E7%9F%A9%E9%98%B5/">矩阵</a></p><p class="categories"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a> / <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%9F%A9%E9%98%B5/">矩阵</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">RichardSpace</a><p class="is-size-7"><span>&copy; 2021 richard</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/RichardSpace369"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>