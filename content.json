{"pages":[],"posts":[{"title":"二叉树","text":"二叉查找树一棵二叉查找树（BST）是一棵二叉树，其中每个结点都含有一个Comparable的键（以及相关联的值）且每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意结点的键 二叉查找树有两个性质。 第一个是每个结点的值均大于其左子树上任意一个结点的值。 第二个是每个结点的值均小于其右子树上任意一个结点的值 我们可以把二叉查找树当作是二分查找算法思想的树形结构体现 比较的次数取决于树的高度。所以如果结点数为n，而且树的形状又较为均衡的话，比较大小和移动的次数最多就是log2n。因此，时间复杂度为O（logn）。但是，如果树的形状朝单侧纵向延伸，树就会变得很高，此时时间复杂度也就变成了O（n）。 线索二叉树最优二叉树赫夫曼树（Huffman Tree）又叫最优二叉树，指的是对于一组具有确定权值的叶子节点的具有最小带权路径长度的二叉树。赫夫曼树在实际工作中有着广泛的应用。 平衡二叉查找树B树题目构建二叉查找树题目描述： 已知15个无序元素{75，85，7，13，9，10，19，91，21，37，56，64，80，33，88}，编写程序使用这些无序元素创建一个二叉排序树，并输出排序结果。 解题思路：在做个题目，之前一定要想想什么是二叉排序树，以及要使用什么遍历方法(这里是中序遍历) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168/** * @description 无序元素构建为二叉排序树 * {75,85,7,13,9,10,19,91,21,37,56,64,80,33,88} * */class NodeData { constructor(data) { this.data = data; this.left = null; this.rigth = null; }}class BinaryTree { constructor() { this.root = null; } /** * @description 插入节点 * @param {@} data */ insert(data) { const nodeData = new NodeData(data); // 如果根节点为空，则这个元素直接为根节点 if (this.root === null) { this.root = nodeData; } else { let current = this.root, // 当前遍历节点 preNode = null; // 父节点 // 不断遍历 直到找到空为值 while (current) { preNode = current; if (current.data &lt; data) { current = current.rigth; } else { current = current.left; } } // 父节点 和需要插入的值进行比较 if (data &lt; preNode.data) { preNode.left = nodeData; } else { preNode.rigth = nodeData; } } } /** * @description 移除某个节点 * 移除一个节点有三种情况 * 1: 叶子节点，无左右子节点，那么直接移除就可以了 * 2: 有一个子节点，那么直接将子节点放到被移除的节点即可 * 3: 有左右子节点，那么需从二叉排序树的中序遍历中找出被删除节点的后继节点(该后继节点的值应该比被删除节点大， * 那么该节点就应该位于被删除节点的右子树。同时，被删除节点的后继节点又应该比后续其他节点的值都要小， * 因此，该节点应该是被删除节点右子树中的最小值，根据二叉排序树的特点，最小值应该是位于右子树的最左侧的叶节点) */ removeNode(node, data) { if (node === null) return null; if (data === node.data) { // 如果没有子节点 if (node.left === null &amp;&amp; node.rigth === null) { return null; } // 如果只有右子节点 if (node.left === null) { return node.rigth; } // 如果只有左子节点 if (node.rigth === null) { return node.left; } // 如果有两个子节点，那么找到后继节点 var tempNode = this.getSmallest(node.right); node.data = tempNode.data; node.right = removeNode(node.right, tempNode.data); return node; } else if (data &gt; node.data) { this.removeNode(node.rigth, data); } else { this.removeNode(node.left, data); } } getSmallest(node) { if (node.left == null) { return node; } else { return getSmallest(node.left); } } getMaxDepth(node) { if (!node) return 0; return ( Math.max(this.getMaxDepth(root.left), this.getMaxDepth(root.right)) + 1 ); } /** * @description 查找某个值的节点 */ findData(data) { let current = this.root; while (current) { if (current.data &lt; data) { current = current.rigth; } else if (current.data &gt; data) { current = current.left; } else { return current; } } return -1; } /** * @description 先序遍历 * 先序遍历就是先遍历根节点，再依次遍历左叶子节点和右叶子节点 */ preorderTraversal(node) { const result = []; result.push(node.data); if (node.left) { result.push(...this.preorderTraversal(node.left)); } if (node.rigth) { result.push(...this.preorderTraversal(node.rigth)); } return result; } /** * @description 中序遍历 * 中序遍历是先遍历左子节点，再遍历根节点，最后再遍历右叶子节点 */ speciesTraversal(node) { const result = []; if (node.left) { result.push(...this.speciesTraversal(node.left)); } result.push(node.data); if (node.rigth) { result.push(...this.speciesTraversal(node.rigth)); } return result; } /** * @description 后序遍历 * 后序遍历是先遍历左子节点，右子节点，根节点 */ postOrderTraversal(node) { const result = []; if (node.left) { result.push(...this.speciesTraversal(node.left)); } if (node.rigth) { result.push(...this.speciesTraversal(node.rigth)); } result.push(node.data); return result; } showData() { const current = this.root; }}const tree = new BinaryTree();const elements = [75, 85, 7, 13, 9, 10, 19, 91, 21, 37, 56, 64, 80, 33, 88];elements.forEach((element) =&gt; { return tree.insert(element);});console.log('先序遍历:', tree.preorderTraversal(tree.root));console.log('中序遍历:', tree.speciesTraversal(tree.root));console.log('后序遍历:', tree.postOrderTraversal(tree.root));","link":"/2021/03/04/data/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"安全算法","text":"传输数据时的四个问题 窃听A向B发送的消息可能会在传输途中被X偷看 假冒A以为向B发送了消息，然而B有可能是X冒充的；反过来，B以为从A那里收到了消息，然而A也有可能是X冒充的。 篡改即便B确实收到了A发送的消息，但也有可能像右图这样，该消息的内容在途中就被X更改了 事后否认B从A那里收到了消息，但作为消息发送者的A可能对B抱有恶意，并在事后声称“这不是我发送的消息” 为了应对第一个问题“窃听”，我们会使用”加密”技术。为了应对第二个问题“假冒”，我们会使用”消息认证码”或”数字签名”技术。为了应对第三个问题“篡改”，我们同样会使用“消息认证码”或“数字签名”技术。其中“数字签名”技术还可以用于预防第四个问题“事后否认” 理解加密首先，计算机会用由0和1这两个数字表示的二进制来管理所有数据 对计算机来说，数据就是一串有意义的数字罗列。密文也是数字罗列，只不过它是计算机无法理解的无规律的数字罗列。 加密就是用密钥对数据进行数值运算，把数据变成第三者无法理解的形式的过程 哈希函数 无论数据规模，输出长度不变 输入的数据相同，那么输出的哈希值也必定相同 即使输入的数据相似，但哪怕它们只有一比特的差别，那么输出的哈希值也会有很大的差异 即使输入的两个数据完全不同，输出的哈希值也有可能是相同的，虽然出现这种情况的概率比较低。这种情况叫作“哈希冲突 不可能从哈希值反向推算出原本的数据。输入和输出不可逆这一点和加密有很大不同。 哈希函数的算法中具有代表性的是MD5、SHA-1和SHA-2等。其中SHA-2是现在应用较为广泛的一个，而MD5和SHA-1存在安全隐患，不推荐使用 共享密钥加密加密数据的方法可以分为两种：加密和解密都使用相同密钥的“共享密钥加密”和分别使用不同密钥的“公开密钥加密” 实现共享密钥加密的算法有凯撒密码、AES、DES、动态口令等，其中AES的应用最为广泛 问题：密钥有被第三者窃听的风险 因此需要找到可以把密钥安全送出的方法，这就是“密钥分配问题” 要想解决这个问题，可以使用“密钥交换协议”和“公开密钥加密”两种方法。 公开密钥加密公开密钥加密是加密和解密使用不同密钥的一种加密方法。由于使用的密钥不同，所以这种算法也被称为“非对称加密”。加密用的密钥叫作“公开密钥”，解密用的叫作“私有密钥”。 实现公开密钥加密的算法有RAS算法、椭圆曲线加密算法等，其中使用最为广泛的是RSA算法 公开密钥的可靠性会出现问题，就是因为A无法判断收到的公开密钥是否来自B(中间人攻击)。要想解决这个问题，就要用到之后会讲到的“数字证书”。 公开密钥加密还有一个问题，那就是加密和解密都比较耗时，所以这种方法不适用于持续发送零碎数据的情况。要想解决这个问题，就要用到“混合加密”。 混合加密共享密钥加密存在无法安全传输密钥的密钥分配问题，公开密钥加密又存在加密解密速度较慢的问题。结合这两种方法以实现互补的一种加密方法就是混合加密。 在混合加密中，要用处理速度较快的共享密钥加密对数据进行加密。不过，加密时使用的密钥，则需要用没有密钥分配问题的公开密钥加密进行处理。 混合加密在安全性和处理速度上都有优势。能够为网络提供通信安全的SSL协议也应用了混合加密方法。SSL是Secure Sockets Layer（安全套接层）的简写，该协议经过版本升级后，现在已正式命名为TLS（TransportLayer Security，传输层安全） 迪菲-赫尔曼密钥交换迪菲-赫尔曼（Diffie-Hellman）密钥交换是一种可以在通信双方之间安全交换密钥的方法。这种方法通过将双方共有的秘密数值隐藏在公开数值相关的运算中，来实现双方之间密钥的安全交换。 合成密钥的方法具有如下特征： 第一，即使持有密钥P和合成的密钥P-S，也无法把密钥S单独取出来。 第二，不管是怎样合成而来的密钥，都可以把它作为新的元素，继续与别的密钥进行合成。比如上图中的这个例子，使用密钥P和密钥P-S，还能合成出新的密钥P-P-S 第三，密钥的合成结果与合成顺序无关，只与用了哪些密钥有关。比如合成密钥B和密钥C后，得到的是密钥B-C，再将其与密钥A合成，得到的就是密钥A-B-C。而合成密钥A和密钥C后，得到的是密钥A-C，再将其与密钥B合成，得到的就是密钥B-A-C。此处的密钥A-B-C和密钥B-A-C是一样的 消息认证码消息认证码可以实现“认证”和“检测篡改”这两个功能。密文的内容在传输过程中可能会被篡改，这会导致解密后的内容发生变化，从而产生误会。消息认证码就是可以预防这种情况发生的机制。 我们以A正要向B发送密文的时候举例 A生成了一个用于制作消息认证码的密钥，然后使用安全的方法将密钥发送给了B。 A使用密文和密钥生成一个值。此处生成的是7f05。这个由密钥和密文生成的值就是消息认证码，以下简称为MAC（Message Authentication Code）。 A将MAC（7f05）和密文(密文使用的是安全的交换方式)发送给B。 B也需要使用密文和密钥来生成MAC。经过对比，B可以确认自己计算出来的7f05和A发来的7f05一致 B只需使用密钥对密文进行解密即可。最终B成功取得了A发送过来的商品编号abc。 我们可以把MAC想象成是由密钥和密文组成的字符串的“哈希值”。计算MAC的算法有HMAC、OMAC、CMAC等。目前，HMAC的应用最为广泛。 缺点： 在使用消息认证码的过程中，AB双方都可以对消息进行加密并且算出MAC。也就是说，我们无法证明原本的消息是A生成的还是B生成的。 因此，假如A是坏人，他就可以在自己发出消息后声称“这条消息是B捏造的”，而否认自己的行为。如果B是坏人，他也可以自己准备一条消息，然后声称“这是A发给我的消息”。 使用MAC时，生成的一方和检测的一方持有同样的密钥，所以不能确定MAC由哪方生成。这个问题可以用下一节将会讲到的“数字签名”来解决。 数字签名数字签名不仅可以实现消息认证码的认证和检测篡改功能，还可以预防事后否认问题的发生。由于在消息认证码中使用的是共享密钥加密，所以持有密钥的收信人也有可能是消息的发送者，这样是无法预防事后否认行为的。而数字签名是只有发信人才能生成的，因此使用它就可以确定谁是消息的发送者了。 数字签名的生成使用的是公开密钥加密。 那就是，虽然使用数字签名后B会相信消息的发送者就是A，但实际上也有可能是X冒充了A 其根本原因在于使用公开密钥加密无法确定公开密钥的制作者是谁。收到的公开密钥上也没有任何制作者的信息。因此，公开密钥有可能是由某个冒充A的人生成的 使用“数字证书”就能解决这个问题。 数字证书公开密钥加密”和“数字签名”无法保证公开密钥确实来自信息的发送者。因此，就算公开密钥被第三者恶意替换，接收方也不会注意到。不过，如果使用本节讲解的数字证书，就能保证公开密钥的正确性 那就是，B得到的公开密钥PC真的来自认证中心吗？ 由于公开密钥自身不能表示其制作者，所以有可能是冒充认证中心的X所生成的。也就是说，这里同样存在公开密钥问题 实际上，认证中心的公开密钥PC是以数字证书的形式交付的，会有更高级别的认证中心对这个认证中心署名","link":"/2021/03/04/data/%E5%AE%89%E5%85%A8%E7%AE%97%E6%B3%95/"},{"title":"数组","text":"集合、列表和数组的概念之间的差别集合 由一个或多个确定的元素所构成的整体 集合具有如下特征 集合里的元素类型不一定相同 集合里面的元素没有顺序 列表 是一种数据项构成的有限序列，即按照一定的线性顺序，排列而成的数据项的集合。 列表的概念是在集合的特征上形成的，它具有顺序，且长度是可变的。你可以把它看作一张购物清单： 列表的另一种实现方式——链表，它的元素在内存中则不一定是连续的 数组数组是采用顺序存储的线性表，即顺序表 那么如何从宏观上区分列表和数组呢？这里有一个重要的概念：索引。 首先，数组会用一些名为 索引 的数字来标识每项数据在数组中的位置，且在大多数编程语言中，索引是从 0 算起的。我们可以根据数组中的索引，快速访问数组中的元素。 而列表中没有索引，这是数组与列表最大的不同点。 其次，数组中的元素在内存中是连续存储的，且每个元素占用相同大小的内存 静态分配 固定大小长度 动态分配 在程序运行过程中，根据需要动态分配一段连续的空间（大小为 Maxsize），用 elem 记录该空间的基地址（首地址），用 length 记录实际的元素个数，即顺序表的长度,在运算过程中，如果发生溢出，可以另外开辟一块更大的存储空间，用以替换原来的存储空间，从而达到扩充存储空间的目的。 顺序查找 通过将频繁查找到的元素置于数据集的起始位置来最小化查找次数 由于对数据的查找遵循“80-20原则”，因此将你的数据转化为自组织的形式是很有意义的。“80-20原则”是指对某一数据集执行的80%的查找操作都是对其中20%的数据元素进行查找。自组织的方式最终会把这20%的数据置于数据集的起始位置，这样便可以通过一个简单的顺序查找快速找到它们 不断的将查询数据向前移动大体实现：不断的将查找的元素向前移动，查找的次数越多，那么数据将越来靠近前面，减少查询次数 1234567891011121314151617function swap(arr, index, index1) { temp = arr[index]; arr[index] = arr[index1]; arr[index1] = temp;}function seqSearch(arr, data) { for (var i = 0; i ＜ arr.length; ++i) { if (arr[i] == data) { if (i ＞ 0) { swap(arr, i, i-1); } return true; } } return false;} 更好的组织方式 将找到的元素移动到数据集的起始位置，但是如果这个元素已经很接近起始位置，则不会对它的位置进行交换 例如下面的实现逻辑：就是将查找到的元素移动到前20%的位置，如果已经在前20%的位置则不用移动 123456789101112function seqSearch(arr, data) { for (var i = 0; i ＜ arr.length; ++i) { if (arr[i] == data &amp;&amp; i ＞ (arr.length * 0.2)) { swap(arr, i,0); return true; } else if (arr[i] == data) { return true; } } return false;} 二分查找折半查找（Binary Search）又称为二分查找。它要求数据序列呈线性结构，也就是要保证需要查找的数据序列是有序的。对于没有经过排序的数据，可以通过排序算法进行预排序，然后进行折半查找的操作 折半查找的具体过程是：假设有n个元素的查找表，首先计算位于查找表中间位置元素的序号m（m=n/2），取s[m]的关键字与给定值key进行比较，其中s[m]是这个有序序列（查找表）的中间分界点，它将有序序列分为前半部分和后半部分。比较结果有3种可能 （1）若s[m]=key，表示查找成功。（2）若s[m]&gt;key，表示关键字key只可能在查找表的前半部分（因查找表中的数据是按从小到大的顺序排列），则在前半部分继续进行折半查找。 （3）若s[m]&lt;key，表示关键字key只可能在查找表的后半部分，则在后半部分继续进行折半查找。 二分查找理解优缺点·优点：查找速度快，最多查找次数为O（nlog2n） ·缺点：对查找表中的数据有顺序要求，在进行查找前可使用上一章介绍的方法首先进行排序。如果需要将查找不成功的关键字数据添加到查找表中，则需要对查找表中的已有数据进行大量的移动操作。 二分查找实现123456789101112131415function binSearch(arr, data) { var upperBound = arr.length-1; var lowerBound = 0; while (lowerBound ＜= upperBound) { var mid = Math.floor((upperBound + lowerBound) / 2); if (arr[mid] ＜ data) { lowerBound = mid + 1; }else if (arr[mid] ＞ data) { upperBound = mid - 1; }else { return mid; } } return -1;} leetcode题目合并两个有序数组题目描述： 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。 解题方法： 先合并再排序,再返回排序后得数组(非原地修改) 双指针 / 从前往后(原地修改，o(m+n)) 这个方法空间复杂度为1，因为需要新建一个变量来拷贝num1，但是这个方法时间复杂度已经达到最优解 12345678910111213141516171819202122var merge = function(nums1, m, nums2, n) { // 第一步：复制num1 let newArr1 = [...nums1]; // 第二步：建立双指针，分别指向nums1,nums2 let p1 = 0, p2 = 0; p = 0; while (p1 &lt; m &amp;&amp; p2 &lt; n) { nums1[p++] = newArr1[p1] &lt; nums2[p2] ? newArr1[p1++] : nums2[p2++]; } // 如果nums1 还剩余得有参数则拼接在后面 if (p1 &lt; m) { nums1 = nums1.concat(nums1.slice(p1)); } // 如果mun2 还剩余得有参数则拼接在后面 if (p2 &lt; n) { nums1 = nums1.concat(nums2.slice(p2)); } return nums1;};console.log(merge([1, 2, 3], 3, [2, 4, 6], 3)); 双指针/从后往前 这个思路比上面得方法优化在不需要额外空间来存储实现思路1：第一步建立双指针2：然后比较NUM1,NUM2,得最后一个元素哪个大 1234567891011121314 var merge = function(nums1, m, nums2, n) { // 第一步：建立双指针，分别指向nums1,nums2 let p1 = m - 1, p2 = n - 1, p = m + n - 1; // 第二步，比较num1，和num2最大得值，哪个最大，就放在nums1 得最后位置 while (p1 &gt;= 0 &amp;&amp; p2 &gt;= 0) { nums1[p--] = nums1[p1] &lt; nums2[p2] ? nums2[p2--] : nums1[p1--]; } return nums1;};console.log(merge([1, 2, 3], 3, [2, 4, 6], 3)); 变位词组题目描述: 编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。 思路：建立hashTable来保存结果，然后将每个字符串进行排序 12345678910var groupAnagrams = function(strs) { let map = new Map() for( let str of strs ){ let key = str.split('').sort().join('') map.has(key) ? map.get(key).push(str) : map.set(key,[str]) } return [...map.values()]};console.log(groupAnagrams(['eat', 'tea', 'tan', 'ate', 'nat', 'bat'])); 搜索旋转数组旋转数组题目描述： 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 解题方法： 利用js API slice和concat方法12345var rotate = function(nums, k) { const traget = nums.length - k; return nums.slice(traget).concat(nums.slice(0, traget));};console.log(rotate([1, 2, 3, 4, 5, 6, 7], 3)); 利用取模方法并创建一个新数组，生成的新数组就是想要的结果123456789101112var rotate = function(nums, k) { const n = nums.length; const newArr = []; // 注意这里取模得对象是Length，相当于把每个数向右移动，最后得几位数取模就自动覆盖到前面去了 for (let i = 0; i &lt; n; ++i) { newArr[(i + k) % n] = nums[i]; } for (let i = 0; i &lt; n; ++i) { nums[i] = newArr[i]; }};console.log(rotate([1, 2, 3, 4, 5, 6, 7], 3)); 数组翻转 空间复杂度O(1) 12345678910111213141516 const reverse = (nums, start, end) =&gt; { while (start &lt; end) { const temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; start += 1; end -= 1; }}var rotate = function(nums, k) { k %= nums.length; reverse(nums, 0, nums.length - 1);//翻转所有元素 reverse(nums, 0, k - 1);//翻转 [0, k\\bmod n - 1][0,kmodn−1] 区间的元素 reverse(nums, k, nums.length - 1);//翻转 [k\\bmod n, n - 1][kmodn,n−1] 区间的元素}; 寻找旋转排序数组中的最小值Ⅰ题目描述: 假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] 。 请找出其中最小的元素。 解题方法： 这个题目，一开始没看懂考察什么 借助Math.min 直接得到最小的值 先排序再取第一个元素 暴力解法，直接找最小元素 二分搜索法 1234567891011121314151617181920212223242526272829303132333435363738/** * @param {number[]} nums * @return {number} */var findMin = function(nums) { // 数组长度为1,直接取第一个元素返回 if (nums.length === 1) { return nums[0]; } // 如果数组是未经过翻转的元素，直接取最小值即可 let left = 0, right = nums.length - 1; if (nums[left] &lt; nums[right]) { return nums[left]; } // while (right &gt;= left) { let mid = left + (right - left) / 2; // 最小值在中间元素右侧 if (nums[mid] &gt; nums[mid + 1]) { return nums[mid + 1]; } // 最小值在中间元素左侧 if (nums[min - 1] &gt; nums[mid]) { return nums[mid]; } // 中间元素大于第一个元素，需要在右侧查找 if (nums[mid] &gt; nums[0]) { left = mid + 1; // 中间元素小于第一个元素，则需要在左侧查找 } else { right = mid - 1; } } return -1;};console.log(findMin([4, 5, 6, 7, 2, 3])); 寻找旋转排序数组中的最小值II题目描述：假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 请找出其中最小的元素。 注意数组中可能存在重复的元素 解题思路： 寻找数组的中心索引题目描述：给你一个整数数组 nums，请编写一个能够返回数组 “中心索引” 的方法。 数组 中心索引 是数组的一个索引，其左侧所有元素相加的和等于右侧所有元素相加的和。 如果数组不存在中心索引，返回 -1 。如果数组有多个中心索引，应该返回最靠近左边的那一个。 注意：中心索引可能出现在数组的两端。 解题思路： 假设数组总和为total,当遍历到第I个元素的时候，左侧之和为sum，则右侧之和为total-sum-nums(i),左右两侧元素相等即为sum=toal-nums(i)-sum,即即 2xsum+nums(i)=total 1234567891011var pivotIndex = function(nums) { const total = nums.reduce((a, b) =&gt; a + b, 0); let sum = 0; for (let i = 0; i &lt; nums.length; i++) { if (2 * sum + nums[i] === total) { return i; } sum += nums[i]; } return -1;}; 合并区间题目描述：以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。 解题思路： 先排序再比较 1234567891011121314151617181920212223242526272829303132333435/** * @param {number[][]} intervals * @return {number[][]} */var merge = function(intervals) { const results = []; // 按照左侧端点进行排序 const sortedInetrvals = intervals.sort((a, b) =&gt; a[0] - b[0]); for (let i = 0; i &lt; sortedInetrvals.length; ) { // 当前遍历元素的左端 let t = sortedInetrvals[i][1]; // 第二个指针 let k = i + 1; // 如果第二个元素的第0位小于前面的一个 while (k &lt; sortedInetrvals.length &amp;&amp; sortedInetrvals[k][0] &lt;= t) { console.log('组合一次'); // 取最大值 t = Math.max(t, sortedInetrvals[k][1]); ++k; } results.push([sortedInetrvals[i][0], t]); // 这个时候将i 赋值位K i = k; } return results;};console.log( merge([ [1, 3], [2, 6], [8, 10], [15, 18], ]));","link":"/2021/03/04/data/%E6%95%B0%E7%BB%84/"},{"title":"栈","text":"一种具有先进后出特征的数据结构 栈得实现123456789101112131415161718192021222324252627class Stack { constructor() { this.stack = []; } //只能向栈顶添加元素 push(item) { this.stack.push(item); } // 只能从栈顶移除元素 pop() { return this.stack.pop(); } // 查看栈顶元素 peek() { return this.stack[this.stack.length - 1]; } isEmpty() { return !this.stack.length; } size() { return this.stack.length; } clear() { this.stack = []; }} 栈题目最小栈实现方式 1： 借用另一个栈，在入栈的时候，比较这个元素和另一个栈顶元素(当前栈的最小元素)的大小 1234567891011121314151617181920212223242526272829303132333435363738class MinStatck { constructor() { this.stack = []; this.minValuesStatck = []; // 这里借用另一个数组充当另一个栈 } //只能向栈顶添加元素 push(item) { if (!this.minValuesStatck.length || item &lt; this.minValuesStatck[this.minValuesStatck.length - 1]) { this.minValuesStatck.push(item); } this.stack.push(item); } // 只能从栈顶移除元素 pop() { const removeValue = this.stack.pop(); if (removeValue &lt; this.minValuesStatck[0]) { this.minValuesStatck.pop(); } return removeValue; } // 查看栈顶元素 peek() { return this.stack[this.stack.length - 1]; } isEmpty() { return !this.stack.length; } size() { return this.stack.length; } clear() { this.stack = []; } getMin() { return this.minValuesStatck[this.minValuesStatck.length - 1]; }}const 实现方式 2：只使用一个栈 进制转换得问题用队列实现一个栈实现 1：使用两个队列实现思路：1: 第一个队列用于保存入栈的数据2：在出栈的时候，将第一个队列的元素一次出队(保留最后一个元素)并保留到队列 2 中3：取出队列 1 的最后一个元素，将队列 2 的数据放到队列 1 中4: 返回最后一个元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 队列是先进先出class Queue { constructor() { this.data = []; } enqueue(val) { this.data.push(val); } dequeue() { return this.data.shift(); } size() { return this.data.length; } empty() { this.data = []; }}// 栈是先出后出class Statck { constructor() { this.queue = new Queue(); } push(val) { this.queue1.enqueue(val); } pop() { // 保留最后一个元素 while (this.queue1.length &gt; 1) { // 将queue1出队的元素添加到queue2去 this.queue2.enqueue(this.queue1.dequeue()); } // 返回最后一个元素 const result = this.queue1.dequeue(); // 将queue2的元素再添加到queue去 while (this.queue2.length &gt; 1) { this.queue1.enqueue(this.queue2.dequeue()); } return result; } toString() { return this.queue1.data; }} 实现 2：使用一个队列实现思路： 在出栈的时候，将队列的元素依次出队(最后一个元素不加入)，然后依次再入队，形成一个循环 最后一个元素就变到队列首部去了 正常队列(返回队首元素，也就是需要出栈的元素) 1234567891011121314151617181920212223242526272829303132333435363738394041// 队列是先进先出class Queue { constructor() { this.data = []; } enqueue(val) { this.data.push(val); } dequeue() { return this.data.shift(); } size() { return this.data.length; } empty() { this.data = []; }}// 栈是先出后出class Statck { constructor() { this.queue = new Queue(); } push(val) { this.queue.enqueue(val); } pop() { // 记录当前队列个数 let size = this.queue.size(); while (size !== 1) { size--; // 不断出队，并将出队的元素入队，形成一个循环 this.queue.enqueue(this.queue.dequeue()); } // 队列顶部元素就是要返回的栈元素 return this.queue.dequeue(); } toString() { return this.queue.data; }} 实现表达式求值算法 实现思路 将操作数压入操作数栈； 将运算符压入运算符栈； 忽略左括号； 在遇到右括号时，弹出一个运算符，弹出所需数量的操作数，并将运算符和操作数的运算结果压入操作数栈。 123456789101112131415161718192021222324252627282930313233343536function Evaluate(str) { const opsStack = [];// 保存运算符得栈 const valsStatck = [];// 保存值得栈 const len = str.length; for (let i = 0; i &lt; len; i++) { switch (str[i]) { case '(': break;// 如果是左括号直接忽略 case '+': case '-': case '*': case '/': opsStack.push(str[i]);// 运算符就入栈 break; case ')':// 如果是右括号，就从运算符里面出栈一个，数值栈里面出栈两个来执行 const op = opsStack.pop(); const v = Number(valsStatck.pop()); let result = 0; if (op === '+') { result = Number(valsStatck.pop()) + v; } else if (op === '*') { result = valsStatck.pop() * v; } else if (op === '-') { result = valsStatck.pop() - v; } else if (op === '/') { result = valsStatck.pop() / v; } valsStatck.push(result);// 将运算结果再次入栈 break; default: valsStatck.push(str[i]); } } return valsStatck.pop(); } console.log(Evaluate('(1+((2+3)*(4*5)))')); //101 单调栈 单调栈」就是栈内元素满足单调性的栈结构。此处的单调性分为单调递增与单调递减，为了便于描述，接下来以「单调递增栈」为例进行讲解。 「单调递增栈」就是栈内元素满足单调递增，假设当前元素为 x，若栈顶元素 ≤ x，则将 x 入栈，否则不断弹出栈顶元素，直至栈顶元素 ≤ x。 我们仍以 3 1 4 5 2 7 为例，其「单调递增栈」具体过程如下图所示。不难发现，入栈结束后，栈中仅保留了 1 2 7，其中 3 由于比 1 大被弹出，而 4 与 5 则由于比 2 大被弹出。 单调栈的根本作用在于求得「每一个数字在原始序列中左 / 右边第一个大于 / 小于它自身的数字」，并且由于每一个数字只会入栈一次且最多出栈一次，因此总的时间复杂度为 O(n)。","link":"/2021/03/04/data/%E6%A0%88/"},{"title":"矩阵","text":"矩阵矩阵本质上是一个二维数组 二维数组是一种结构较为特殊的数组，只是将数组中的每个元素变成了一维数组。 所以二维数组的本质上仍然是一个一维数组，内部的一维数组仍然从索引 0 开始，我们可以将它看作一个矩阵，并处理矩阵的相关问题。 leetcode 题目旋转矩阵(https://leetcode-cn.com/problems/rotate-image/)题目描述：给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。","link":"/2021/03/04/data/%E7%9F%A9%E9%98%B5/"},{"title":"队列","text":"队列是一种具有先进先出的数据结构 队列的基本实现12345678910111213141516171819202122232425262728293031323334class Queue { constructor() { this.count = 0; this.lowestCount = 0; // 队首 this.items = {}; } enqueue(item) { this.items[this.count++] = item; } dequeue() { if (this.isEmpty()) { return undefined; } const result = this.items[this.lowestCount]; delete this.items[this.lowestCount]; this.lowestCount++; return result; } // 返回队列的第一个元素 peek() { return this.isEmpty() ? undefined : this.items[this.lowestCount]; } isEmpty() { return this.count - this.lowestCount === 0; } size() { return this.count - this.lowestCount; } clear() { this.items = {}; this.count = 0; this.lowestCount = 0; }} 双端队列端队列同时遵守了先进先出和后进先出原则,即可以在队尾，队首都可以入队和出队 散列表实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Deque { constructor() { this.count = 0; // 队尾 this.lowestCount = 0; // 队首 this.items = {}; // 存储 } // 前端添加元素 addFront(item) { // 如果为空 直接在队尾添加元素 if (this.isEmpty()) { this.addBack(item); // 如果当前队首不为0，直接在队首前面相加即可 } else if (this.lowestCount &gt; 0) { this.items[--this.lowestCount] = item; this.count++; } else { // 如果当前队首为0，则需要进行群移操作 for (let i = this.count; i &gt; 0; i--) { this.items[i] = this.items[i - 1]; } this.count++; this.lowestCount = 0; this.items[0] = item; } } // 后端添加元素 addBack(item) { this.items[this.count++] = item; } // 前端移除元素 removeFront() {} // 后端移除元素 removeBack() {} // 返回队列的第一个元素 peek() { return this.isEmpty() ? undefined : this.items[this.lowestCount]; } isEmpty() { return this.count - this.lowestCount === 0; } size() { return this.count - this.lowestCount; } clear() { this.items = {}; this.count = 0; this.lowestCount = 0; } toString() { let str = ''; for (let i = this.lowestCount; i &lt; this.count; i++) { str += this.items[i] + ' '; } return str; }} 数组实现 123456789101112131415161718192021222324252627282930313233343536class Queue { constructor() { this.items = []; } //最坏： O(n) 最好:O(1) addFront(item) { this.items.unshift(item); } //O(1) addBack(item) { this.items.push(item); } //O(n) removeFront() { return this.items.shift(); } //O(1) removeBack() { return this.items.pop(); } peek() { return this.items[0]; } isEmpty() { return this.items.length === 0; } size() { return this.items.length; } clear() { this.items = []; } toString() { return this.items.toString(); }} 循环队列循环队列 主要是解决的如果队列大小固定，则主要解决的是空间浪费的情况 实现方式：利用指针指向的概念 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class CircularQueue { constructor(limit) { this.limit = limit; this.head = -1;// 指向队首的元素 this.tail = -1;// 指向队尾的元素 this.items = {}; } //从队首获取元素。如果队列为空，返回 -1 Front() { if (this.isEmpty()) { return -1; } return this.items[this.head]; } //获取队尾元素。如果队列为空，返回 -1 。 Rear() { if (this.isEmpty()) { return -1; } return this.items[this.tail]; } //向循环队列插入一个元素。如果成功插入则返回真 enQueue(item) { if (this.isFull()) { return false; } // 如果队列为空，则将队首置为0 if (this.isEmpty()) { this.head = 0; } // 理解这一步，入栈的时候，移动队尾指针，利用的是循环特性 //1 因为出队肯定是出的第一个，第二个，第三个，...这样的顺序 //2 tail 刚好是 1,2,3,4,5,1,2,3,5 这样的顺序 this.tail = (this.tail + 1) % this.limit; this.items[this.tail] = item; return true; } // 出栈一个元素 // 并不需要主动移除元素，利用的是指针指向的 deQueue() { if (this.isEmpty()) { return false; } // 如果移除的是最后一个元素 if (this.head === this.tail) { this.head = -1; this.tail = -1; return true; } // 出栈的时候，移动队首指针 this.head = (this.head + 1) % this.limit; return true; } isEmpty() { return this.head === -1; } isFull() { return (this.tail + 1) % this.limit === this.head; } toString() { let str = ''; for (let i in this.items) { str += this.items[i]; } return str; }} 单调队列 单调队列，即单调递减或单调递增的队列。使用频率不高，但在有些程序中会有非同寻常的作用。 优先队列 普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest out）的行为特征。通常采用堆数据结构来实现。 队列题目比如我们 Js 的 event-loop 就是利用的队列先进先出的特性 击鼓传花游戏字符串回文(双端队列)","link":"/2021/03/04/data/%E9%98%9F%E5%88%97/"}],"tags":[],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"栈","slug":"数据结构与算法/栈","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%88/"},{"name":"二叉树","slug":"数据结构与算法/二叉树","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"矩阵","slug":"数据结构与算法/矩阵","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%9F%A9%E9%98%B5/"},{"name":"队列","slug":"数据结构与算法/队列","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/"},{"name":"安全算法","slug":"数据结构与算法/安全算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AE%89%E5%85%A8%E7%AE%97%E6%B3%95/"},{"name":"数组","slug":"数据结构与算法/数组","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/"}]}