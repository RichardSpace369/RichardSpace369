{"pages":[],"posts":[{"title":"二叉树","text":"二叉查找树一棵二叉查找树（BST）是一棵二叉树，其中每个结点都含有一个Comparable的键（以及相关联的值）且每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意结点的键 二叉查找树有两个性质。 第一个是每个结点的值均大于其左子树上任意一个结点的值。 第二个是每个结点的值均小于其右子树上任意一个结点的值 我们可以把二叉查找树当作是二分查找算法思想的树形结构体现 比较的次数取决于树的高度。所以如果结点数为n，而且树的形状又较为均衡的话，比较大小和移动的次数最多就是log2n。因此，时间复杂度为O（logn）。但是，如果树的形状朝单侧纵向延伸，树就会变得很高，此时时间复杂度也就变成了O（n）。 线索二叉树最优二叉树赫夫曼树（Huffman Tree）又叫最优二叉树，指的是对于一组具有确定权值的叶子节点的具有最小带权路径长度的二叉树。赫夫曼树在实际工作中有着广泛的应用。 平衡二叉查找树B树题目构建二叉查找树题目描述： 已知15个无序元素{75，85，7，13，9，10，19，91，21，37，56，64，80，33，88}，编写程序使用这些无序元素创建一个二叉排序树，并输出排序结果。 解题思路：在做个题目，之前一定要想想什么是二叉排序树，以及要使用什么遍历方法(这里是中序遍历) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168/** * @description 无序元素构建为二叉排序树 * {75,85,7,13,9,10,19,91,21,37,56,64,80,33,88} * */class NodeData { constructor(data) { this.data = data; this.left = null; this.rigth = null; }}class BinaryTree { constructor() { this.root = null; } /** * @description 插入节点 * @param {@} data */ insert(data) { const nodeData = new NodeData(data); // 如果根节点为空，则这个元素直接为根节点 if (this.root === null) { this.root = nodeData; } else { let current = this.root, // 当前遍历节点 preNode = null; // 父节点 // 不断遍历 直到找到空为值 while (current) { preNode = current; if (current.data &lt; data) { current = current.rigth; } else { current = current.left; } } // 父节点 和需要插入的值进行比较 if (data &lt; preNode.data) { preNode.left = nodeData; } else { preNode.rigth = nodeData; } } } /** * @description 移除某个节点 * 移除一个节点有三种情况 * 1: 叶子节点，无左右子节点，那么直接移除就可以了 * 2: 有一个子节点，那么直接将子节点放到被移除的节点即可 * 3: 有左右子节点，那么需从二叉排序树的中序遍历中找出被删除节点的后继节点(该后继节点的值应该比被删除节点大， * 那么该节点就应该位于被删除节点的右子树。同时，被删除节点的后继节点又应该比后续其他节点的值都要小， * 因此，该节点应该是被删除节点右子树中的最小值，根据二叉排序树的特点，最小值应该是位于右子树的最左侧的叶节点) */ removeNode(node, data) { if (node === null) return null; if (data === node.data) { // 如果没有子节点 if (node.left === null &amp;&amp; node.rigth === null) { return null; } // 如果只有右子节点 if (node.left === null) { return node.rigth; } // 如果只有左子节点 if (node.rigth === null) { return node.left; } // 如果有两个子节点，那么找到后继节点 var tempNode = this.getSmallest(node.right); node.data = tempNode.data; node.right = removeNode(node.right, tempNode.data); return node; } else if (data &gt; node.data) { this.removeNode(node.rigth, data); } else { this.removeNode(node.left, data); } } getSmallest(node) { if (node.left == null) { return node; } else { return getSmallest(node.left); } } getMaxDepth(node) { if (!node) return 0; return ( Math.max(this.getMaxDepth(root.left), this.getMaxDepth(root.right)) + 1 ); } /** * @description 查找某个值的节点 */ findData(data) { let current = this.root; while (current) { if (current.data &lt; data) { current = current.rigth; } else if (current.data &gt; data) { current = current.left; } else { return current; } } return -1; } /** * @description 先序遍历 * 先序遍历就是先遍历根节点，再依次遍历左叶子节点和右叶子节点 */ preorderTraversal(node) { const result = []; result.push(node.data); if (node.left) { result.push(...this.preorderTraversal(node.left)); } if (node.rigth) { result.push(...this.preorderTraversal(node.rigth)); } return result; } /** * @description 中序遍历 * 中序遍历是先遍历左子节点，再遍历根节点，最后再遍历右叶子节点 */ speciesTraversal(node) { const result = []; if (node.left) { result.push(...this.speciesTraversal(node.left)); } result.push(node.data); if (node.rigth) { result.push(...this.speciesTraversal(node.rigth)); } return result; } /** * @description 后序遍历 * 后序遍历是先遍历左子节点，右子节点，根节点 */ postOrderTraversal(node) { const result = []; if (node.left) { result.push(...this.speciesTraversal(node.left)); } if (node.rigth) { result.push(...this.speciesTraversal(node.rigth)); } result.push(node.data); return result; } showData() { const current = this.root; }}const tree = new BinaryTree();const elements = [75, 85, 7, 13, 9, 10, 19, 91, 21, 37, 56, 64, 80, 33, 88];elements.forEach((element) =&gt; { return tree.insert(element);});console.log('先序遍历:', tree.preorderTraversal(tree.root));console.log('中序遍历:', tree.speciesTraversal(tree.root));console.log('后序遍历:', tree.postOrderTraversal(tree.root));","link":"/2021/03/05/data/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"安全算法","text":"传输数据时的四个问题 窃听A向B发送的消息可能会在传输途中被X偷看 假冒A以为向B发送了消息，然而B有可能是X冒充的；反过来，B以为从A那里收到了消息，然而A也有可能是X冒充的。 篡改即便B确实收到了A发送的消息，但也有可能像右图这样，该消息的内容在途中就被X更改了 事后否认B从A那里收到了消息，但作为消息发送者的A可能对B抱有恶意，并在事后声称“这不是我发送的消息” 为了应对第一个问题“窃听”，我们会使用”加密”技术。为了应对第二个问题“假冒”，我们会使用”消息认证码”或”数字签名”技术。为了应对第三个问题“篡改”，我们同样会使用“消息认证码”或“数字签名”技术。其中“数字签名”技术还可以用于预防第四个问题“事后否认” 理解加密首先，计算机会用由0和1这两个数字表示的二进制来管理所有数据 对计算机来说，数据就是一串有意义的数字罗列。密文也是数字罗列，只不过它是计算机无法理解的无规律的数字罗列。 加密就是用密钥对数据进行数值运算，把数据变成第三者无法理解的形式的过程 哈希函数 无论数据规模，输出长度不变 输入的数据相同，那么输出的哈希值也必定相同 即使输入的数据相似，但哪怕它们只有一比特的差别，那么输出的哈希值也会有很大的差异 即使输入的两个数据完全不同，输出的哈希值也有可能是相同的，虽然出现这种情况的概率比较低。这种情况叫作“哈希冲突 不可能从哈希值反向推算出原本的数据。输入和输出不可逆这一点和加密有很大不同。 哈希函数的算法中具有代表性的是MD5、SHA-1和SHA-2等。其中SHA-2是现在应用较为广泛的一个，而MD5和SHA-1存在安全隐患，不推荐使用 共享密钥加密加密数据的方法可以分为两种：加密和解密都使用相同密钥的“共享密钥加密”和分别使用不同密钥的“公开密钥加密” 实现共享密钥加密的算法有凯撒密码、AES、DES、动态口令等，其中AES的应用最为广泛 问题：密钥有被第三者窃听的风险 因此需要找到可以把密钥安全送出的方法，这就是“密钥分配问题” 要想解决这个问题，可以使用“密钥交换协议”和“公开密钥加密”两种方法。 公开密钥加密公开密钥加密是加密和解密使用不同密钥的一种加密方法。由于使用的密钥不同，所以这种算法也被称为“非对称加密”。加密用的密钥叫作“公开密钥”，解密用的叫作“私有密钥”。 实现公开密钥加密的算法有RAS算法、椭圆曲线加密算法等，其中使用最为广泛的是RSA算法 公开密钥的可靠性会出现问题，就是因为A无法判断收到的公开密钥是否来自B(中间人攻击)。要想解决这个问题，就要用到之后会讲到的“数字证书”。 公开密钥加密还有一个问题，那就是加密和解密都比较耗时，所以这种方法不适用于持续发送零碎数据的情况。要想解决这个问题，就要用到“混合加密”。 混合加密共享密钥加密存在无法安全传输密钥的密钥分配问题，公开密钥加密又存在加密解密速度较慢的问题。结合这两种方法以实现互补的一种加密方法就是混合加密。 在混合加密中，要用处理速度较快的共享密钥加密对数据进行加密。不过，加密时使用的密钥，则需要用没有密钥分配问题的公开密钥加密进行处理。 混合加密在安全性和处理速度上都有优势。能够为网络提供通信安全的SSL协议也应用了混合加密方法。SSL是Secure Sockets Layer（安全套接层）的简写，该协议经过版本升级后，现在已正式命名为TLS（TransportLayer Security，传输层安全） 迪菲-赫尔曼密钥交换迪菲-赫尔曼（Diffie-Hellman）密钥交换是一种可以在通信双方之间安全交换密钥的方法。这种方法通过将双方共有的秘密数值隐藏在公开数值相关的运算中，来实现双方之间密钥的安全交换。 合成密钥的方法具有如下特征： 第一，即使持有密钥P和合成的密钥P-S，也无法把密钥S单独取出来。 第二，不管是怎样合成而来的密钥，都可以把它作为新的元素，继续与别的密钥进行合成。比如上图中的这个例子，使用密钥P和密钥P-S，还能合成出新的密钥P-P-S 第三，密钥的合成结果与合成顺序无关，只与用了哪些密钥有关。比如合成密钥B和密钥C后，得到的是密钥B-C，再将其与密钥A合成，得到的就是密钥A-B-C。而合成密钥A和密钥C后，得到的是密钥A-C，再将其与密钥B合成，得到的就是密钥B-A-C。此处的密钥A-B-C和密钥B-A-C是一样的 消息认证码消息认证码可以实现“认证”和“检测篡改”这两个功能。密文的内容在传输过程中可能会被篡改，这会导致解密后的内容发生变化，从而产生误会。消息认证码就是可以预防这种情况发生的机制。 我们以A正要向B发送密文的时候举例 A生成了一个用于制作消息认证码的密钥，然后使用安全的方法将密钥发送给了B。 A使用密文和密钥生成一个值。此处生成的是7f05。这个由密钥和密文生成的值就是消息认证码，以下简称为MAC（Message Authentication Code）。 A将MAC（7f05）和密文(密文使用的是安全的交换方式)发送给B。 B也需要使用密文和密钥来生成MAC。经过对比，B可以确认自己计算出来的7f05和A发来的7f05一致 B只需使用密钥对密文进行解密即可。最终B成功取得了A发送过来的商品编号abc。 我们可以把MAC想象成是由密钥和密文组成的字符串的“哈希值”。计算MAC的算法有HMAC、OMAC、CMAC等。目前，HMAC的应用最为广泛。 缺点： 在使用消息认证码的过程中，AB双方都可以对消息进行加密并且算出MAC。也就是说，我们无法证明原本的消息是A生成的还是B生成的。 因此，假如A是坏人，他就可以在自己发出消息后声称“这条消息是B捏造的”，而否认自己的行为。如果B是坏人，他也可以自己准备一条消息，然后声称“这是A发给我的消息”。 使用MAC时，生成的一方和检测的一方持有同样的密钥，所以不能确定MAC由哪方生成。这个问题可以用下一节将会讲到的“数字签名”来解决。 数字签名数字签名不仅可以实现消息认证码的认证和检测篡改功能，还可以预防事后否认问题的发生。由于在消息认证码中使用的是共享密钥加密，所以持有密钥的收信人也有可能是消息的发送者，这样是无法预防事后否认行为的。而数字签名是只有发信人才能生成的，因此使用它就可以确定谁是消息的发送者了。 数字签名的生成使用的是公开密钥加密。 那就是，虽然使用数字签名后B会相信消息的发送者就是A，但实际上也有可能是X冒充了A 其根本原因在于使用公开密钥加密无法确定公开密钥的制作者是谁。收到的公开密钥上也没有任何制作者的信息。因此，公开密钥有可能是由某个冒充A的人生成的 使用“数字证书”就能解决这个问题。 数字证书公开密钥加密”和“数字签名”无法保证公开密钥确实来自信息的发送者。因此，就算公开密钥被第三者恶意替换，接收方也不会注意到。不过，如果使用本节讲解的数字证书，就能保证公开密钥的正确性 那就是，B得到的公开密钥PC真的来自认证中心吗？ 由于公开密钥自身不能表示其制作者，所以有可能是冒充认证中心的X所生成的。也就是说，这里同样存在公开密钥问题 实际上，认证中心的公开密钥PC是以数字证书的形式交付的，会有更高级别的认证中心对这个认证中心署名","link":"/2021/03/05/data/%E5%AE%89%E5%85%A8%E7%AE%97%E6%B3%95/"},{"title":"数组","text":"集合、列表和数组的概念之间的差别集合 由一个或多个确定的元素所构成的整体 集合具有如下特征 集合里的元素类型不一定相同 集合里面的元素没有顺序 列表 是一种数据项构成的有限序列，即按照一定的线性顺序，排列而成的数据项的集合。 列表的概念是在集合的特征上形成的，它具有顺序，且长度是可变的。你可以把它看作一张购物清单： 列表的另一种实现方式——链表，它的元素在内存中则不一定是连续的 数组数组是采用顺序存储的线性表，即顺序表 那么如何从宏观上区分列表和数组呢？这里有一个重要的概念：索引。 首先，数组会用一些名为 索引 的数字来标识每项数据在数组中的位置，且在大多数编程语言中，索引是从 0 算起的。我们可以根据数组中的索引，快速访问数组中的元素。 而列表中没有索引，这是数组与列表最大的不同点。 其次，数组中的元素在内存中是连续存储的，且每个元素占用相同大小的内存 静态分配 固定大小长度 动态分配 在程序运行过程中，根据需要动态分配一段连续的空间（大小为 Maxsize），用 elem 记录该空间的基地址（首地址），用 length 记录实际的元素个数，即顺序表的长度,在运算过程中，如果发生溢出，可以另外开辟一块更大的存储空间，用以替换原来的存储空间，从而达到扩充存储空间的目的。 顺序查找 通过将频繁查找到的元素置于数据集的起始位置来最小化查找次数 由于对数据的查找遵循“80-20原则”，因此将你的数据转化为自组织的形式是很有意义的。“80-20原则”是指对某一数据集执行的80%的查找操作都是对其中20%的数据元素进行查找。自组织的方式最终会把这20%的数据置于数据集的起始位置，这样便可以通过一个简单的顺序查找快速找到它们 不断的将查询数据向前移动大体实现：不断的将查找的元素向前移动，查找的次数越多，那么数据将越来靠近前面，减少查询次数 1234567891011121314151617function swap(arr, index, index1) { temp = arr[index]; arr[index] = arr[index1]; arr[index1] = temp;}function seqSearch(arr, data) { for (var i = 0; i ＜ arr.length; ++i) { if (arr[i] == data) { if (i ＞ 0) { swap(arr, i, i-1); } return true; } } return false;} 更好的组织方式 将找到的元素移动到数据集的起始位置，但是如果这个元素已经很接近起始位置，则不会对它的位置进行交换 例如下面的实现逻辑：就是将查找到的元素移动到前20%的位置，如果已经在前20%的位置则不用移动 123456789101112function seqSearch(arr, data) { for (var i = 0; i ＜ arr.length; ++i) { if (arr[i] == data &amp;&amp; i ＞ (arr.length * 0.2)) { swap(arr, i,0); return true; } else if (arr[i] == data) { return true; } } return false;} 二分查找折半查找（Binary Search）又称为二分查找。它要求数据序列呈线性结构，也就是要保证需要查找的数据序列是有序的。对于没有经过排序的数据，可以通过排序算法进行预排序，然后进行折半查找的操作 折半查找的具体过程是：假设有n个元素的查找表，首先计算位于查找表中间位置元素的序号m（m=n/2），取s[m]的关键字与给定值key进行比较，其中s[m]是这个有序序列（查找表）的中间分界点，它将有序序列分为前半部分和后半部分。比较结果有3种可能 （1）若s[m]=key，表示查找成功。（2）若s[m]&gt;key，表示关键字key只可能在查找表的前半部分（因查找表中的数据是按从小到大的顺序排列），则在前半部分继续进行折半查找。 （3）若s[m]&lt;key，表示关键字key只可能在查找表的后半部分，则在后半部分继续进行折半查找。 二分查找理解优缺点·优点：查找速度快，最多查找次数为O（nlog2n） ·缺点：对查找表中的数据有顺序要求，在进行查找前可使用上一章介绍的方法首先进行排序。如果需要将查找不成功的关键字数据添加到查找表中，则需要对查找表中的已有数据进行大量的移动操作。 二分查找实现123456789101112131415function binSearch(arr, data) { var upperBound = arr.length-1; var lowerBound = 0; while (lowerBound ＜= upperBound) { var mid = Math.floor((upperBound + lowerBound) / 2); if (arr[mid] ＜ data) { lowerBound = mid + 1; }else if (arr[mid] ＞ data) { upperBound = mid - 1; }else { return mid; } } return -1;} leetcode题目合并两个有序数组题目描述： 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。 解题方法： 先合并再排序,再返回排序后得数组(非原地修改) 双指针 / 从前往后(原地修改，o(m+n)) 这个方法空间复杂度为1，因为需要新建一个变量来拷贝num1，但是这个方法时间复杂度已经达到最优解 12345678910111213141516171819202122var merge = function(nums1, m, nums2, n) { // 第一步：复制num1 let newArr1 = [...nums1]; // 第二步：建立双指针，分别指向nums1,nums2 let p1 = 0, p2 = 0; p = 0; while (p1 &lt; m &amp;&amp; p2 &lt; n) { nums1[p++] = newArr1[p1] &lt; nums2[p2] ? newArr1[p1++] : nums2[p2++]; } // 如果nums1 还剩余得有参数则拼接在后面 if (p1 &lt; m) { nums1 = nums1.concat(nums1.slice(p1)); } // 如果mun2 还剩余得有参数则拼接在后面 if (p2 &lt; n) { nums1 = nums1.concat(nums2.slice(p2)); } return nums1;};console.log(merge([1, 2, 3], 3, [2, 4, 6], 3)); 双指针/从后往前 这个思路比上面得方法优化在不需要额外空间来存储实现思路1：第一步建立双指针2：然后比较NUM1,NUM2,得最后一个元素哪个大 1234567891011121314 var merge = function(nums1, m, nums2, n) { // 第一步：建立双指针，分别指向nums1,nums2 let p1 = m - 1, p2 = n - 1, p = m + n - 1; // 第二步，比较num1，和num2最大得值，哪个最大，就放在nums1 得最后位置 while (p1 &gt;= 0 &amp;&amp; p2 &gt;= 0) { nums1[p--] = nums1[p1] &lt; nums2[p2] ? nums2[p2--] : nums1[p1--]; } return nums1;};console.log(merge([1, 2, 3], 3, [2, 4, 6], 3)); 变位词组题目描述: 编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。 思路：建立hashTable来保存结果，然后将每个字符串进行排序 12345678910var groupAnagrams = function(strs) { let map = new Map() for( let str of strs ){ let key = str.split('').sort().join('') map.has(key) ? map.get(key).push(str) : map.set(key,[str]) } return [...map.values()]};console.log(groupAnagrams(['eat', 'tea', 'tan', 'ate', 'nat', 'bat'])); 搜索旋转数组旋转数组题目描述： 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 解题方法： 利用js API slice和concat方法12345var rotate = function(nums, k) { const traget = nums.length - k; return nums.slice(traget).concat(nums.slice(0, traget));};console.log(rotate([1, 2, 3, 4, 5, 6, 7], 3)); 利用取模方法并创建一个新数组，生成的新数组就是想要的结果123456789101112var rotate = function(nums, k) { const n = nums.length; const newArr = []; // 注意这里取模得对象是Length，相当于把每个数向右移动，最后得几位数取模就自动覆盖到前面去了 for (let i = 0; i &lt; n; ++i) { newArr[(i + k) % n] = nums[i]; } for (let i = 0; i &lt; n; ++i) { nums[i] = newArr[i]; }};console.log(rotate([1, 2, 3, 4, 5, 6, 7], 3)); 数组翻转 空间复杂度O(1) 12345678910111213141516 const reverse = (nums, start, end) =&gt; { while (start &lt; end) { const temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; start += 1; end -= 1; }}var rotate = function(nums, k) { k %= nums.length; reverse(nums, 0, nums.length - 1);//翻转所有元素 reverse(nums, 0, k - 1);//翻转 [0, k\\bmod n - 1][0,kmodn−1] 区间的元素 reverse(nums, k, nums.length - 1);//翻转 [k\\bmod n, n - 1][kmodn,n−1] 区间的元素}; 寻找旋转排序数组中的最小值Ⅰ题目描述: 假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] 。 请找出其中最小的元素。 解题方法： 这个题目，一开始没看懂考察什么 借助Math.min 直接得到最小的值 先排序再取第一个元素 暴力解法，直接找最小元素 二分搜索法 1234567891011121314151617181920212223242526272829303132333435363738/** * @param {number[]} nums * @return {number} */var findMin = function(nums) { // 数组长度为1,直接取第一个元素返回 if (nums.length === 1) { return nums[0]; } // 如果数组是未经过翻转的元素，直接取最小值即可 let left = 0, right = nums.length - 1; if (nums[left] &lt; nums[right]) { return nums[left]; } // while (right &gt;= left) { let mid = left + (right - left) / 2; // 最小值在中间元素右侧 if (nums[mid] &gt; nums[mid + 1]) { return nums[mid + 1]; } // 最小值在中间元素左侧 if (nums[min - 1] &gt; nums[mid]) { return nums[mid]; } // 中间元素大于第一个元素，需要在右侧查找 if (nums[mid] &gt; nums[0]) { left = mid + 1; // 中间元素小于第一个元素，则需要在左侧查找 } else { right = mid - 1; } } return -1;};console.log(findMin([4, 5, 6, 7, 2, 3])); 寻找旋转排序数组中的最小值II题目描述：假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 请找出其中最小的元素。 注意数组中可能存在重复的元素 解题思路： 寻找数组的中心索引题目描述：给你一个整数数组 nums，请编写一个能够返回数组 “中心索引” 的方法。 数组 中心索引 是数组的一个索引，其左侧所有元素相加的和等于右侧所有元素相加的和。 如果数组不存在中心索引，返回 -1 。如果数组有多个中心索引，应该返回最靠近左边的那一个。 注意：中心索引可能出现在数组的两端。 解题思路： 假设数组总和为total,当遍历到第I个元素的时候，左侧之和为sum，则右侧之和为total-sum-nums(i),左右两侧元素相等即为sum=toal-nums(i)-sum,即即 2xsum+nums(i)=total 1234567891011var pivotIndex = function(nums) { const total = nums.reduce((a, b) =&gt; a + b, 0); let sum = 0; for (let i = 0; i &lt; nums.length; i++) { if (2 * sum + nums[i] === total) { return i; } sum += nums[i]; } return -1;}; 合并区间题目描述：以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。 解题思路： 先排序再比较 1234567891011121314151617181920212223242526272829303132333435/** * @param {number[][]} intervals * @return {number[][]} */var merge = function(intervals) { const results = []; // 按照左侧端点进行排序 const sortedInetrvals = intervals.sort((a, b) =&gt; a[0] - b[0]); for (let i = 0; i &lt; sortedInetrvals.length; ) { // 当前遍历元素的左端 let t = sortedInetrvals[i][1]; // 第二个指针 let k = i + 1; // 如果第二个元素的第0位小于前面的一个 while (k &lt; sortedInetrvals.length &amp;&amp; sortedInetrvals[k][0] &lt;= t) { console.log('组合一次'); // 取最大值 t = Math.max(t, sortedInetrvals[k][1]); ++k; } results.push([sortedInetrvals[i][0], t]); // 这个时候将i 赋值位K i = k; } return results;};console.log( merge([ [1, 3], [2, 6], [8, 10], [15, 18], ]));","link":"/2021/03/05/data/%E6%95%B0%E7%BB%84/"},{"title":"栈","text":"一种具有先进后出特征的数据结构 栈得实现123456789101112131415161718192021222324252627class Stack { constructor() { this.stack = []; } //只能向栈顶添加元素 push(item) { this.stack.push(item); } // 只能从栈顶移除元素 pop() { return this.stack.pop(); } // 查看栈顶元素 peek() { return this.stack[this.stack.length - 1]; } isEmpty() { return !this.stack.length; } size() { return this.stack.length; } clear() { this.stack = []; }} 栈题目最小栈实现方式 1： 借用另一个栈，在入栈的时候，比较这个元素和另一个栈顶元素(当前栈的最小元素)的大小 1234567891011121314151617181920212223242526272829303132333435363738class MinStatck { constructor() { this.stack = []; this.minValuesStatck = []; // 这里借用另一个数组充当另一个栈 } //只能向栈顶添加元素 push(item) { if (!this.minValuesStatck.length || item &lt; this.minValuesStatck[this.minValuesStatck.length - 1]) { this.minValuesStatck.push(item); } this.stack.push(item); } // 只能从栈顶移除元素 pop() { const removeValue = this.stack.pop(); if (removeValue &lt; this.minValuesStatck[0]) { this.minValuesStatck.pop(); } return removeValue; } // 查看栈顶元素 peek() { return this.stack[this.stack.length - 1]; } isEmpty() { return !this.stack.length; } size() { return this.stack.length; } clear() { this.stack = []; } getMin() { return this.minValuesStatck[this.minValuesStatck.length - 1]; }}const 实现方式 2：只使用一个栈 进制转换得问题用队列实现一个栈实现 1：使用两个队列实现思路：1: 第一个队列用于保存入栈的数据2：在出栈的时候，将第一个队列的元素一次出队(保留最后一个元素)并保留到队列 2 中3：取出队列 1 的最后一个元素，将队列 2 的数据放到队列 1 中4: 返回最后一个元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 队列是先进先出class Queue { constructor() { this.data = []; } enqueue(val) { this.data.push(val); } dequeue() { return this.data.shift(); } size() { return this.data.length; } empty() { this.data = []; }}// 栈是先出后出class Statck { constructor() { this.queue = new Queue(); } push(val) { this.queue1.enqueue(val); } pop() { // 保留最后一个元素 while (this.queue1.length &gt; 1) { // 将queue1出队的元素添加到queue2去 this.queue2.enqueue(this.queue1.dequeue()); } // 返回最后一个元素 const result = this.queue1.dequeue(); // 将queue2的元素再添加到queue去 while (this.queue2.length &gt; 1) { this.queue1.enqueue(this.queue2.dequeue()); } return result; } toString() { return this.queue1.data; }} 实现 2：使用一个队列实现思路： 在出栈的时候，将队列的元素依次出队(最后一个元素不加入)，然后依次再入队，形成一个循环 最后一个元素就变到队列首部去了 正常队列(返回队首元素，也就是需要出栈的元素) 1234567891011121314151617181920212223242526272829303132333435363738394041// 队列是先进先出class Queue { constructor() { this.data = []; } enqueue(val) { this.data.push(val); } dequeue() { return this.data.shift(); } size() { return this.data.length; } empty() { this.data = []; }}// 栈是先出后出class Statck { constructor() { this.queue = new Queue(); } push(val) { this.queue.enqueue(val); } pop() { // 记录当前队列个数 let size = this.queue.size(); while (size !== 1) { size--; // 不断出队，并将出队的元素入队，形成一个循环 this.queue.enqueue(this.queue.dequeue()); } // 队列顶部元素就是要返回的栈元素 return this.queue.dequeue(); } toString() { return this.queue.data; }} 实现表达式求值算法 实现思路 将操作数压入操作数栈； 将运算符压入运算符栈； 忽略左括号； 在遇到右括号时，弹出一个运算符，弹出所需数量的操作数，并将运算符和操作数的运算结果压入操作数栈。 123456789101112131415161718192021222324252627282930313233343536function Evaluate(str) { const opsStack = [];// 保存运算符得栈 const valsStatck = [];// 保存值得栈 const len = str.length; for (let i = 0; i &lt; len; i++) { switch (str[i]) { case '(': break;// 如果是左括号直接忽略 case '+': case '-': case '*': case '/': opsStack.push(str[i]);// 运算符就入栈 break; case ')':// 如果是右括号，就从运算符里面出栈一个，数值栈里面出栈两个来执行 const op = opsStack.pop(); const v = Number(valsStatck.pop()); let result = 0; if (op === '+') { result = Number(valsStatck.pop()) + v; } else if (op === '*') { result = valsStatck.pop() * v; } else if (op === '-') { result = valsStatck.pop() - v; } else if (op === '/') { result = valsStatck.pop() / v; } valsStatck.push(result);// 将运算结果再次入栈 break; default: valsStatck.push(str[i]); } } return valsStatck.pop(); } console.log(Evaluate('(1+((2+3)*(4*5)))')); //101 单调栈 单调栈」就是栈内元素满足单调性的栈结构。此处的单调性分为单调递增与单调递减，为了便于描述，接下来以「单调递增栈」为例进行讲解。 「单调递增栈」就是栈内元素满足单调递增，假设当前元素为 x，若栈顶元素 ≤ x，则将 x 入栈，否则不断弹出栈顶元素，直至栈顶元素 ≤ x。 我们仍以 3 1 4 5 2 7 为例，其「单调递增栈」具体过程如下图所示。不难发现，入栈结束后，栈中仅保留了 1 2 7，其中 3 由于比 1 大被弹出，而 4 与 5 则由于比 2 大被弹出。 单调栈的根本作用在于求得「每一个数字在原始序列中左 / 右边第一个大于 / 小于它自身的数字」，并且由于每一个数字只会入栈一次且最多出栈一次，因此总的时间复杂度为 O(n)。","link":"/2021/03/05/data/%E6%A0%88/"},{"title":"矩阵","text":"矩阵矩阵本质上是一个二维数组 二维数组是一种结构较为特殊的数组，只是将数组中的每个元素变成了一维数组。 所以二维数组的本质上仍然是一个一维数组，内部的一维数组仍然从索引 0 开始，我们可以将它看作一个矩阵，并处理矩阵的相关问题。 leetcode 题目旋转矩阵(https://leetcode-cn.com/problems/rotate-image/)题目描述：给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。","link":"/2021/03/05/data/%E7%9F%A9%E9%98%B5/"},{"title":"队列","text":"队列是一种具有先进先出的数据结构 队列的基本实现12345678910111213141516171819202122232425262728293031323334class Queue { constructor() { this.count = 0; this.lowestCount = 0; // 队首 this.items = {}; } enqueue(item) { this.items[this.count++] = item; } dequeue() { if (this.isEmpty()) { return undefined; } const result = this.items[this.lowestCount]; delete this.items[this.lowestCount]; this.lowestCount++; return result; } // 返回队列的第一个元素 peek() { return this.isEmpty() ? undefined : this.items[this.lowestCount]; } isEmpty() { return this.count - this.lowestCount === 0; } size() { return this.count - this.lowestCount; } clear() { this.items = {}; this.count = 0; this.lowestCount = 0; }} 双端队列端队列同时遵守了先进先出和后进先出原则,即可以在队尾，队首都可以入队和出队 散列表实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Deque { constructor() { this.count = 0; // 队尾 this.lowestCount = 0; // 队首 this.items = {}; // 存储 } // 前端添加元素 addFront(item) { // 如果为空 直接在队尾添加元素 if (this.isEmpty()) { this.addBack(item); // 如果当前队首不为0，直接在队首前面相加即可 } else if (this.lowestCount &gt; 0) { this.items[--this.lowestCount] = item; this.count++; } else { // 如果当前队首为0，则需要进行群移操作 for (let i = this.count; i &gt; 0; i--) { this.items[i] = this.items[i - 1]; } this.count++; this.lowestCount = 0; this.items[0] = item; } } // 后端添加元素 addBack(item) { this.items[this.count++] = item; } // 前端移除元素 removeFront() {} // 后端移除元素 removeBack() {} // 返回队列的第一个元素 peek() { return this.isEmpty() ? undefined : this.items[this.lowestCount]; } isEmpty() { return this.count - this.lowestCount === 0; } size() { return this.count - this.lowestCount; } clear() { this.items = {}; this.count = 0; this.lowestCount = 0; } toString() { let str = ''; for (let i = this.lowestCount; i &lt; this.count; i++) { str += this.items[i] + ' '; } return str; }} 数组实现 123456789101112131415161718192021222324252627282930313233343536class Queue { constructor() { this.items = []; } //最坏： O(n) 最好:O(1) addFront(item) { this.items.unshift(item); } //O(1) addBack(item) { this.items.push(item); } //O(n) removeFront() { return this.items.shift(); } //O(1) removeBack() { return this.items.pop(); } peek() { return this.items[0]; } isEmpty() { return this.items.length === 0; } size() { return this.items.length; } clear() { this.items = []; } toString() { return this.items.toString(); }} 循环队列循环队列 主要是解决的如果队列大小固定，则主要解决的是空间浪费的情况 实现方式：利用指针指向的概念 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class CircularQueue { constructor(limit) { this.limit = limit; this.head = -1;// 指向队首的元素 this.tail = -1;// 指向队尾的元素 this.items = {}; } //从队首获取元素。如果队列为空，返回 -1 Front() { if (this.isEmpty()) { return -1; } return this.items[this.head]; } //获取队尾元素。如果队列为空，返回 -1 。 Rear() { if (this.isEmpty()) { return -1; } return this.items[this.tail]; } //向循环队列插入一个元素。如果成功插入则返回真 enQueue(item) { if (this.isFull()) { return false; } // 如果队列为空，则将队首置为0 if (this.isEmpty()) { this.head = 0; } // 理解这一步，入栈的时候，移动队尾指针，利用的是循环特性 //1 因为出队肯定是出的第一个，第二个，第三个，...这样的顺序 //2 tail 刚好是 1,2,3,4,5,1,2,3,5 这样的顺序 this.tail = (this.tail + 1) % this.limit; this.items[this.tail] = item; return true; } // 出栈一个元素 // 并不需要主动移除元素，利用的是指针指向的 deQueue() { if (this.isEmpty()) { return false; } // 如果移除的是最后一个元素 if (this.head === this.tail) { this.head = -1; this.tail = -1; return true; } // 出栈的时候，移动队首指针 this.head = (this.head + 1) % this.limit; return true; } isEmpty() { return this.head === -1; } isFull() { return (this.tail + 1) % this.limit === this.head; } toString() { let str = ''; for (let i in this.items) { str += this.items[i]; } return str; }} 单调队列 单调队列，即单调递减或单调递增的队列。使用频率不高，但在有些程序中会有非同寻常的作用。 优先队列 普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest out）的行为特征。通常采用堆数据结构来实现。 队列题目比如我们 Js 的 event-loop 就是利用的队列先进先出的特性 击鼓传花游戏字符串回文(双端队列)","link":"/2021/03/05/data/%E9%98%9F%E5%88%97/"},{"title":"JSON","text":"理解 JSON 最关键的一点是要把它当成一种数据格式，而不是编程语言。JSON 不属于 JavaScript，它们只是拥有相同的语法而已。JSON 也不是只能在 JavaScript 中使用，它是一种通用数据格式 语法JSON 语法支持表示 3 种类型的值。 简单值：字符串、数值、布尔值和 null 可以在 JSON 中出现，就像在 JavaScript 中一样。特殊值 undefined 不可以。 对象：第一种复杂数据类型，对象表示有序键/值对。每个值可以是简单值，也可以是复杂类型 数组：第二种复杂数据类型，数组表示可以通过数值索引访问的值的有序列表。数组的值可以是任意类型，包括简单值、对象，甚至其他数组。JSON 没有变量、函数或对象实例的概念。 简单值JavaScript 字符串与 JSON 字符串的主要区别是，JSON 字符串必须使用双引号 布尔值和 null 本身也是有效的 JSON 值 对象与 JavaScript 对象字面量相比，JSON 主要有两处不同。 首先，没有变量声明（JSON 中没有变量）。 其次，最后没有分号（不需要，因为不是 JavaScript 语句）。 同样，用引号将属性名包围起来才是有效的JSON。 解析与序列化JSON.stringifyJSON.stringify 方法，除了要序列化的对象，还可以接收两个参数，第一个参数是过滤器,第二个参数是用于缩进结果 JSON 字符串的选项 过滤结果如果第二个参数是一个数组，那么 JSON.stringify()返回的结果只会包含该数组中列出的对象属性 1234567891011let book = { title: &quot;Professional JavaScript&quot;, authors: [ &quot;Nicholas C. Zakas&quot;, &quot;Matt Frisbie&quot; ], edition: 4, year: 2017 }; let jsonText = JSON.stringify(book, [&quot;title&quot;, &quot;edition&quot;]);//{&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;edition&quot;:4} 如果第二个参数是一个函数，则行为又有不同。提供的函数接收两个参数：属性名（key）和属性值（value）。可以根据这个 key 决定要对相应属性执行什么操作。这个 key 始终是字符串，只是在值不属于某个键/值对时会是空字符串。 注意，返回 undefined 会导致属性被忽略 12345678910111213141516171819let book = { title: 'Professional JavaScript', authors: ['Nicholas C. Zakas', 'Matt Frisbie'], edition: 4, year: 2017,};let jsonText = JSON.stringify(book, (key, value) =&gt; { switch (key) { case 'authors': return value.join(','); case 'year': return 5000; case 'edition': return undefined; default: return value; }}); //{&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;authors&quot;:&quot;Nicholas C. Zakas,Matt Frisbie&quot;,&quot;year&quot;:5000} 字符串缩进JSON.stringify()方法的第三个参数控制缩进和空格。 在这个参数是数值时，表示每一级缩进的空格数 如果缩进参数是一个字符串而非数值，那么 JSON 字符串中就会使用这个字符串而不是空格来缩进。使用字符串，也可以将缩进字符设置为 Tab 或任意字符 toJSON()方法有时候，对象需要在 JSON.stringify()之上自定义 JSON 序列化。此时，可以在要序列化的对象中添加 toJSON()方法，序列化时会基于这个方法返回适当的 JSON 表示 123456789101112let book = { title: 'Professional JavaScript', authors: ['Nicholas C. Zakas', 'Matt Frisbie'], edition: 4, year: 2017, toJSON: function() { return this.title; },};let jsonText = JSON.stringify(book);console.log(jsonText);//&quot;Professional JavaScript&quot; 注意，箭头函数不能用来定义 toJSON()方法。主要原因是箭头函数的词法作用域是全局作用域，在这种情况下不合适 JSON()方法可以与过滤函数一起使用，因此理解不同序列化流程的顺序非常重要。在把对象传给 JSON.stringify()时会执行如下步骤。 (1) 如果可以获取实际的值，则调用 toJSON()方法获取实际的值，否则使用默认的序列化。 (2) 如果提供了第二个参数，则应用过滤。传入过滤函数的值就是第(1)步返回的值。 (3) 第(2)步返回的每个值都会相应地进行序列化。 (4) 如果提供了第三个参数，则相应地进行缩进 解析选项 JSON.parse 方法JSON.parse()方法也可以接收一个额外的参数，这个函数(还原函数)会针对每个键/值对都调用一次。这个函数也接收两个参数，属性名（key）和属性值（value），另外也需要返回值 如果还原函数返回 undefined，则结果中就会删除相应的键。如果返回了其他任何值，则该值就会成为相应键的值插入到结果中。 还原函数经常被用于把日期字符串转换为 Date 对象 手动实现 JSON.stringify","link":"/2021/03/05/javascript/JSON/"},{"title":"generator","text":"generator Generator 函数是 ES6 提供的一种异步编程解决方案 调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束 注意：一种情况就是return 当genertator 函数内部有return 语句的时候，会直接返回{value:[return的值]，done:true},但是for of 循环的时候，是不会循环到这里的 12345678910111213141516function* test() { yield 1; yield 2; return 3; yield 4;}for (let i of test()) { console.log(i);// 这里将打印出1，2 }const p = test();console.log(p.next()); //{ value: 1, done: false }console.log(p.next()); //{ value: 2, done: false }console.log(p.next()); //{ value: 3, done: true }console.log(p.next()); //{ value: undefined, done: true } next方法的参数我们可以在执行next的时候，传递一个参数作为上一次yield 表达式返回的值(默认是undefind),但是第一次调用next方法的时候即使传入参数也是undefind for of 循环前面提到Generator 函数会返回一个迭代对象，所以我们可以用for of 来循环Generator函数 Generator.prototype.throw()Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。 1234567891011function* test() { try { yield; } catch (e) { console.log(e); // 打印出错误 }}const p = test();p.throw('自定义错误'); 注意1：如果多次使用throw 抛出错误，只有第一次抛出错误会在generator函数内部捕捉，之后抛出的错误就需要在外部使用try catch来包裹了，如果函数内部没有try catch 那么也需要在外部去捕捉 注意2：另外 throw方法抛出的错误要被内部捕获，前提是必须至少执行过一次next方法。否则就会在外部捕捉 注意3： throw方法被捕获以后，会附带执行下一条yield表达式。也就是说，会附带执行一次next方法。 123456789101112131415var gen = function* gen() { try { yield console.log('a'); } catch (e) { // ... } yield console.log('b'); yield console.log('c');};var g = gen();g.next(); // ag.throw(); // bg.next(); // c Generator.prototype.return()Generator 函数返回的遍历器对象，还有一个return()方法，可以返回给定的值，并且终结遍历 Generator 函数。 generator 函数的异步应用ES6 诞生以前，异步编程的方法，大概有下面四种。 回调函数 事件监听 发布/订阅 Promise 对象","link":"/2021/03/05/javascript/generator/"},{"title":"Object","text":"理解Object在JavaScript中，几乎所有的对象都是Object类型的实例，它们都会从Object.prototype继承属性和方法。Object 构造函数为给定值创建一个对象包装器。Object构造函数，会根据给定的参数创建对象，具体有以下情况： 如果给定值是 null 或 undefined，将会创建并返回一个空对象 如果传进去的是一个基本类型的值，则会构造其包装类型的对象 如果传进去的是引用类型的值，仍然会返回这个值，经他们复制的变量保有和源对象相同的引用地址 当以非构造函数形式被调用时，Object 的行为等同于 new Object()。 Object 构造函数的方法Object.assign() Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。 如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性。 Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。 Object.create() Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。 Object.defineProperty() Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象 Object.defineProperties()Object.entries()Object.keys() 返回一个包含所有给定对象自身可枚举属性名称的数组。 Object.values() 返回给定对象自身可枚举值的数组。 Object.getOwnPropertyNames()Object.getOwnPropertySymbols()Object.preventExtensions()和Object.isExtensible() 防止对象的任何扩展。 Object.freeze()和 Object.isFrozen() 冻结对象：其他代码不能删除或更改任何属性。注意:Object.freeze 只能冻结一层对象 123456789const person={ age:26, address:{ prefix:&quot;xxx&quot; }}const frezzPerson=Object.freeze(person)frezzPerson.age=28// 修改不成功frezzPerson.address.prefix=&quot;yyyy&quot;// 修改成功 Object.getPrototypeOf()和Object.setPrototypeOf()Object.is() 比较两个值是否相同。所有 NaN 值都相等（这与==和===不同）。 Object.isSealed() Object.isSealed() 方法判断一个对象是否被密封。 Object 原型上的方法Object.prototype.hasOwnProperty() 返回一个布尔值 ，表示某个对象是否含有指定的属性，而且此属性非原型链继承的。 Object.prototype.isPrototypeOf() 返回一个布尔值，表示指定的对象是否在本对象的原型链中。 Object.prototype.propertyIsEnumerable() 判断指定属性是否可枚举","link":"/2021/03/05/javascript/object/"},{"title":"promise","text":"理解promise Promise 对象用于表示一个异步操作的最终完成 (或失败)及其结果值。 Promise 的原型上的方法Promise.prototype.then(onFulfilled, onRejected) 添加解决(fulfillment)和拒绝(rejection)回调到当前 promise, 返回一个新的 promise, 将以回调的返回值来resolve. 接收参数： 这个方法，将在期约函数执行完毕之后执行，这个方法可以接收两个参数都不是必须的，第一个参数是用于处理 onResovled 情况，其接收的参数是 promise 内部调用 resolve 函数传递的参数，第二个参数是处理 onRejected 情况。其接收的参数是 promise 内部调用 reject 函数的参数。这个方法返回一个新的期约对象 如果在调用这个参数的时候传递了一个非函数类型的值，会直接忽略这个值,例如 12345const p = Promise.resolve(1);p.then(2).then((x) =&gt; { console.log(x); // 接收的是1}); 如果接收的函数返回一个期约对象将原封不动的返回这个期约对象 12345const p = Promise.resolve(1);p.then(() =&gt; Promise.resolve(2)).then((x) =&gt; { console.log(x); // 接收的是2});这个函数的then 方法接收一个返回期约对象的函数 如果接收的函数返回的是其他数据，那么程序将会调用 Promise.resolve 包装这个返回的值，如果没有显示的返回语句，将使用 Promise.resolve 包装一个 undefind 返回 如果接收的函数抛出错误，那么就会返回拒绝的期约即使用 Promise.reject 进行包裹错误 1234567891011const p = Promise.resolve(1);p.then(() =&gt; { throw new Error('p 产生了错误');}) .then((x) =&gt; { console.log(x); // 接收的是2 }) .catch((error) =&gt; { console.error('error:', error); }); 如果接收的函数返回错误，而不是抛出错误，那么将继续使用 Promise.resolve 包裹这个返回的对象 1let p11 = p1.then(() =&gt; Error('qux')); 需要注意的一点是：then 方法的第二个参数是代表处理 onRejected 的情况，这个函数返回的值同样也会被 Promise.resolve 进行包裹 1234567const p = Promise.reject('错误');p.then(null, () =&gt; { return 'onRejected 返回的值';}).then((x) =&gt; { console.log(x); // 'onRejected 返回的值';}); Promise.prototype.catch()Promise.prototype.catch()方法用于给期约添加拒绝处理程序。这个方法只接收一个参数：onRejected 处理程序。事实上，这个方法就是一个语法糖，调用它就相当于调用 Promise.prototype.then(null, onRejected) Promise.prototype.finally无论是 rejected 状态还是 resolved 状态都会执行 Promise 的静态方法Promise.all(iterable)这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。这个新的promise对象在触发成功状态以后，会把一个包含iterable里所有promise返回值的数组作为成功回调的返回值，顺序跟iterable的顺序保持一致；如果这个新的promise对象触发了失败状态，它会把iterable里第一个触发失败的promise对象的错误信息作为它的失败错误信息。Promise.all方法常被用于处理多个promise对象的状态集合 123456789101112131415161718const promiseSuccess = new Promise((resolve, reject) =&gt; { setTimeout(resolve, 1000, 1);});const promiseFail = new Promise((resolve, reject) =&gt; { setTimeout(reject, 1000, 'error');});// 全部执行成功将会在then里面第一个参数中返回一个数组Promise.all([promiseSuccess, promiseSuccess]).then((res) =&gt; { console.log(res); //[1,1]});// 有一个执行失败则触发rejectPromise.all([promiseSuccess, promiseFail]) .then((res) =&gt; { console.log(res); //[1,1] }) .catch((error) =&gt; { console.log(error); }); 注意1:如果传入得是参数不包含任何promise，则返回一个异步完成 12345const test = Promise.all([1, 2, 3]).then((result) =&gt; { console.log('result', result); //[1,2,3]});console.log(test); // promise pending 状态 **注意2:**如果接收得是一个空的可迭代得对象则返回一个已完成得同步状态(注意是同步状态) 12const test = Promise.all([]);console.log(test); // Promise { [] } 注意3：，如果作为参数的 Promise 实例，自己定义了 catch 方法，那么它一旦被 rejected，并不会触发 Promise.all()的 catch 方法。 12345678910111213141516const p1 = new Promise((resolve, reject) =&gt; { resolve('hello');}).then(result =&gt; result).catch(e =&gt; e);const p2 = new Promise((resolve, reject) =&gt; { throw new Error('报错了');}).then(result =&gt; result).catch(e =&gt; e);Promise.all([p1, p2]).then(result =&gt; console.log(result)).catch(e =&gt; console.log(e));// [&quot;hello&quot;, Error: 报错了] Promise.race 方法Promise.resolve 方法promise.resolve 接收的参数有多种情况 如果接收的是一个 Promise 实例，则原封不动的返回这个实例 如果接收的参数是一个 thenable 对象,Promise.resolve()方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then()方法。 如果参数是一个原始值，或者是一个不具有 then()方法的对象，则 Promise.resolve()方法返回一个新的 Promise 对象，状态为 resolved。 Promise.resolve()方法允许调用时不带参数，直接返回一个 resolved 状态的 Promise 对象。 另外要注意的是 Promise.resolve 和 Promise.reject 总是异步执行的 1234567891011try { throw Error();} catch (err) { console.log('err1', err); // 打印}try { Promise.reject(Error()); // 直接报错，这个错误捕捉不到} catch (err) { console.log('err2', err); // 未打印} Promise.rejectPromise.allSettled;等到所有promises都已敲定（settled）（每个promise都已兑现（fulfilled）或已拒绝（rejected））。返回一个promise，该promise在所有promise完成后完成。并带有一个对象数组，每个对象对应每个promise的结果。 该方法返回的新的 Promise 实例，一旦结束，状态总是 fulfilled，不会变成 rejected。状态变成 fulfilled 后，Promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入 Promise.allSettled()的 Promise 实例。 Promise.allSettled()的返回值 allSettledPromise，状态只可能变成 fulfilled。它的监听函数接收到的参数是数组 results。该数组的每个成员都是一个对象，对应传入 Promise.allSettled()的两个 Promise 实例。每个对象都有 status 属性，该属性的值只可能是字符串 fulfilled 或字符串 rejected。fulfilled 时，对象有 value 属性，rejected 时有 reason 属性，对应两种状态的返回值 接收参数得情况和promise.all 是保持一致得 注意：catch函数永远不会执行，即使抛出错误 1234567891011121314const promise1 = Promise.resolve(3);const promise2 = new Promise((resolve, reject) =&gt; setTimeout(reject, 100, 'foo'));const promises = [promise1, promise2];Promise.allSettled(promises) .then((results) =&gt; { console.log(results); //[{ status: 'fulfilled', value: 3 },{ status: 'rejected', reason: 'foo' }] }) .catch((error) =&gt; { console.log(error); // 不会执行 }); Promise.any该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成 fulfilled 状态，包装实例就会变成 fulfilled 状态；如果所有参数实例都变成 rejected 状态，包装实例就会变成 rejected 状态。 Promise.try不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误 Promise 的缺点以及解决方案期约不具备的两个特性(期约取消和状态进度) ES6 不支持取消期约和进度通知，一个主要原因就是这样会导致期约连锁和期约合成过度复杂化。比如在一个期约连锁中，如果某个被其他期约依赖的期约被取消了或者发出了通知，那么接下来应该发生什么完全说不清楚。毕竟，如果取消了 Promise.all()中的一个期约，或者期约连锁中前面的期约发送了一个通知，那么接下来应该怎么办才比较合理呢？ 期约取消 使用bluebird 提供的promise来做 使用原生promise增加cancle状态来实现 1234567891011121314151617181920212223242526272829303132333435function updateUser() { let resolveFn, rejectFn, cancled = false; // 延迟返回状态 const promise = new Promise((resolve, reject) =&gt; { resolveFn = resolve; reject = rejectFn; }); //在这里真正执行函数和判断是否已经取消 function wrapWithCancel(fn) { return (data) =&gt; { if (!cancled) { fn(data); } }; } fetchUser() .then(wrapWithCancel(updateUserData)) .then(wrapWithCancel(updateUserAddress)) .then(wrapWithCancel(updateMarketingData)) .then(resolveFn) .catch(rejectFn); return { promise, cancle: () =&gt; { cancled = true; rejectFn({ reson: '取消' }); }, };}const { promise, cancle } = updateUser();// later some timecancle();// 执行取消操作 状态进度promise面试题实现一个串行调用的promise1234567891011121314151617181920212223242526function start(tasks) { var result = []; return tasks.reduce((accumulator, item, index) =&gt; { return accumulator.then((res) =&gt; { result.push(res); return index == tasks.length - 1 ? item.then((res) =&gt; { result.push(res); return result; }) : item; }); }, Promise.resolve(0));}function delay(time) { return new Promise(function(resolve, reject) { setTimeout(function() { resolve(time); }, time); });}start([delay(2000), delay(2000), delay(1000)]).then((res) =&gt; { console.log(res); //[undefined,undefined,1000]}); 实现多个Promise 异步执行并拿到返回结果1234567891011121314151617181920function execter(arr) { return new Promise((resolve) =&gt; { let result = []; function setData(data) { result.push(data); if (arr.length === result.length) { resolve(result); } } arr.forEach(promise =&gt; { promise .then(data =&gt; { setData(data); }) .catch(err =&gt; { setData(null); }); }); });} 使用Promise实现每隔1秒输出1,2,3注意这个方案是直接创建了三个settimeout函数然后设置了不同的时间而已 123456789function outpUT(arr) { arr.reduce((pre, next) =&gt; { return pre.then(() =&gt; { setTimeout(console.log, next * 1000, next); }); }, Promise.resolve());}outpUT([1, 2, 3]); 使用Promise实现红绿灯交替重复亮 红灯3秒亮一次，黄灯2秒亮一次，绿灯1秒亮一次；如何让三个灯不断交替重复亮灯？（用Promise实现）三个亮灯函数已经存在： 1234567891011121314151617181920212223242526272829303132333435363738394041424344function red() { console.log('red');}function green() { console.log('green');}function yellow() { console.log('yellow');}/** * @description 创建真正执行打印的函数 * @param {*} time * @param {*} fn * @returns */function light(time, fn) { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { fn(); resolve(); }, time); });}/** * @description 执行函数，依次执行红黄绿，然后递归调用 * @returns */function step() { return Promise.resolve() .then(() =&gt; { return light(3000, red); }) .then(() =&gt; { return light(2000, yellow); }) .then(() =&gt; { return light(1000, green); }) .then(() =&gt; { return step(); });}step(); 限制异步操作的并发个数并尽可能快的完成全部有8个图片资源的url，已经存储在数组urls中。urls类似于[‘https://image1.png', ‘https://image2.png', ….]而且已经有一个函数function loadImg，输入一个url链接，返回一个Promise，该Promise在图片下载完成的时候resolve，下载失败则reject。但有一个要求，任何时刻同时下载的链接数量不可以超过3个。请写一段代码实现这个需求，要求尽可能快速地将所有图片下载完成。 实现方法如下： 先取出Limit(假设是3)个元素来形成一个数组，并发出请求 迭代length-limit个元素，在迭代的每一次中，拿到上面最快执行完毕的下标，并且用下一个元素来替代这个下标的位置 最后执行(promise.all)剩下的三个元素 这个方案：有个问题就是假设我们需要拿到执行的请求结果那么这个方法就是有缺陷的，可以思考一下 改进思路：就是建立一个Map然后改造hander，然后在Handler里面去设置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172var urls = [ 'https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting1.png', 'https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting2.png', 'https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting3.png', 'https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting4.png', 'https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting5.png', 'https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn6.png', 'https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn7.png', 'https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn8.png', ]; function loadImg(url) { return new Promise((resolve, reject) =&gt; { const img = new Image(); img.onload = function() { console.log('一张图片加载完成'); resolve(img); }; img.onerror = function() { reject(new Error('Could not load image at' + url)); }; img.src = url; }); } /** * @ 思路：第一次先一次执行limit个，然后在里面每个执行完毕了再从url中取一个出来去执行 * @param {*} urls * @param {*} limit */ function limitLoad(urls, handler, limit) { // 赋值URLs let sequence = [].concat(urls); // 先取前三个元素发出请求，但是这里是没有处理请求结果的 let promises = sequence.splice(0, limit).map((url, index) =&gt; { return handler(url).then(() =&gt; { return index; // 注意：返回的是下标元素 }); }); // 迭代剩下的未发出请求的图片 return ( sequence .reduce((pCollect, url) =&gt; { return pCollect .then(() =&gt; { // 使用promise race 是保证尽快拿到已经请求结束的图片的下标 return Promise.race(promises); }) .then((fastestIndex) =&gt; { // 拿到前面请求最快的元素下标然后发出这个请求，并且让这个请求占据原来的位置 promises[fastestIndex] = handler(url).then(() =&gt; { return fastestIndex; // 要继续将这个下标返回，以便下一次变量 }); }) .catch((err) =&gt; { console.error(err); }); }, Promise.resolve()) // 初始化传入 // 因为上面最多只调用7次，但是已经补充了请求到promises里面，则把剩余的执行完毕 .then(() =&gt; { // 最后三个用.all来调用 return Promise.all(promises); }) ); } limitLoad(urls, loadImg, 3) .then((res) =&gt; { console.log('图片全部加载完毕'); console.log(res); }) .catch((err) =&gt; { console.error(err); });","link":"/2021/03/05/javascript/promise/"},{"title":"this","text":"为什么要用this我们思考如下代码，就是利用this来实现的 1234567891011121314151617function identify() { return this.name.toUpperCase();}function speak() { var greeting = 'hello ,I am ' + identify.call(this); console.log(greeting);}var me = { name: 'Kyle',};var you = { name: 'reader',};identify.call(me);identify.you(me);speak.call(me);speak.call(you); 这段代码可以在不同的上下文对象（me和you）中重复使用函数identify()和speak()，不用针对每个对象编写不同版本的函数。如果不使用this，那就需要给identify()和speak()显式传入一个上下文对象 this提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将API设计得更加简洁并且易于复用 this 到底是什么this是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。 当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。this就是这个记录的一个属性，会在函数执行的过程中用到 this 全面解析绑定规则默认绑定独立函数调用 12345function foo(){ console.log(this.a)}var a=2;foo()// 2 因为在本例中，函数调用时应用了this的默认绑定，因此this指向全局对象。 如果使用严格模式，则不能将全局对象应用于默认绑定，this会绑定到undefind 那么我们怎么知道这里应用了默认绑定呢？可以通过分析调用位置来看看foo()是如何调用的。在代码中，foo()是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则 123456function foo(){ &quot;use strict&quot; console.log(this.a)// this 指向undefind}var a=2;foo()// 报错 这里有一个微妙但是非常重要的细节，虽然this的绑定规则完全取决于调用位置，但是只有foo()运行在非strict mode下时，默认绑定才能绑定到全局对象；在严格模式下调用foo()则不影响默认绑定 123456789function foo(){ console.log(this.a)// this 指向undefind}var a=2;(function(){ &quot;use strict&quot; foo()})() 隐式绑定当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象 12345678function foo(){ console.log(this.a)}var obj={ a:2, foo,}obj.foo()//2 对象属性引用链中只有上一层或者说最后一层在调用位置中起作用 123456789101112function foo(){ console.log(this.a)}var obj2={ a:42, foo,}var obj1={ a:2, obj2:obj2}obj1.obj2.foo() //2 隐式丢失 一个最常见的this绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把this绑定到全局对象或者undefined上，取决于是否是严格模式。 1234567891011function foo() { console.log(this.a);}var obj = { a: 2, foo,};var bar = obj.foo;var a = 'oop';bar(); //&quot;oop&quot; 一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时 12345678910111213function foo() { console.log(this.a);}function doFoo(fn) { fn();}var obj = { a: 2, foo,};var a = 'oop';doFoo(obj.foo); // &quot;oop&quot; 调用回调函数的函数可能会修改this 在一些流行的JavaScript库中事件处理器常会把回调函数的this强制绑定到触发事件的DOM元素上 显示绑定JavaScript提供的绝大多数函数以及你自己创建的所有函数都可以使用call(..)和apply(..)方法。 它们的第一个参数是一个对象，是给this准备的，接着在调用函数时将其绑定到this。因为你可以直接指定this的绑定对象，因此我们称之为显式绑定。 注意：如果你传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作this的绑定对象，这个原始值会被转换成它的对象形式（也就是new String(..)、newBoolean(..)或者new Number(..)）。这通常被称为“装箱” 可惜，显式绑定仍然无法解决我们之前提出的丢失绑定问题。 硬绑定 12345678910111213function foo(something){ console.log(this.a,something) return this.a+something}var obj={ a:2}var bar=function(){ return foo.apply(obj,arguments)// 硬绑定}var b=bar(3)console.log(b)//5 API调用的“上下文” 第三方库的许多函数，以及JavaScript语言和宿主环境中许多新的内置函数，都提供了一个可选的参数，通常被称为“上下文”（context），其作用和bind(..)一样，确保你的回调函数使用指定的this。 new绑定使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 创建（或者说构造）一个全新的对象。 这个新对象会被执行[[Prototype]]连接。 这个新对象会绑定到函数调用的this。 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。 优先级 显式绑定优先级更高，也就是说在判断时应当先考虑是否可以存在显式 new和显示绑定，new 的优先级更高 绑定例外被忽略的this如果你把null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则 然而，总是使用null来忽略this绑定可能产生一些副作用。如果某个函数确实使用了this（比如第三方库中的一个函数），那默认绑定规则会把this绑定到全局对象（在浏览器中这个对象是window），这将导致不可预计的后果（比如修改全局对象）。 更安全的this一种“更安全”的做法是传入一个特殊的对象(空对象)，把this绑定到这个对象不会对你的程序产生任何副作用。 在JavaScript中创建一个空对象最简单的方法都是Object.create(null) 间接引用另一个需要注意的是，你有可能（有意或者无意地）创建一个函数的“间接引用”，在这种情况下，调用这个函数会应用默认绑定规则。 12345678910111213function foo(){ console.log(this.a)}var a=2;var o={ a:3, foo,}var p={ a:4}o.foo()//3(p.foo=o.foo)()//2 赋值表达式p.foo = o.foo的返回值是目标函数的引用，因此调用位置是foo()而不是p.foo()或者o.foo()。根据我们之前说过的，这里会应用默认绑定。 注意：对于默认绑定来说，决定this绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，this会被绑定到undefined，否则this会被绑定到全局对象。 箭头函数箭头函数不使用this的四种标准规则，而是根据外层（函数或者全局）作用域来决定this。 箭头函数的绑定无法被修改。（new也不行！）","link":"/2021/03/05/javascript/this/"},{"title":"客户端存储","text":"cookiecookie 是与特定域绑定的。设置 cookie 后，它会与请求一起发送到创建它的域 不超过 300 个 cookie； 每个 cookie 不超过 4096 字节； 每个域不超过 20 个 cookie； 每个域不超过 81 920 字节。 如果 cookie 总数超过了单个域的上限，浏览器就会删除之前设置的 cookie。IE 和 Opera 会按照最近最少使用（LRU，Least Recently Used）原则删除之前的 cookie，以便为新设置的 cookie 腾出空间。Firefox好像会随机删除之前的 cookie，因此为避免不确定的结果，最好不要超出限制 cookie的构成cookie 在浏览器中是由以下参数构成的。 名称：唯一标识 cookie 的名称。cookie 名不区分大小写，因此 myCookie 和 MyCookie 是同一个名称。不过，实践中最好将 cookie 名当成区分大小写来对待，因为一些服务器软件可能这样对待它们。cookie 名必须经过 URL 编码。 值：存储在 cookie 里的字符串值。这个值必须经过 URL 编码。 域：cookie 有效的域。发送到这个域的所有请求都会包含对应的 cookie。这个值可能包含子域（如www.wrox.com），也可以不包含（如.wrox.com 表示对 wrox.com 的所有子域都有效）。如果不明确设置，则默认为设置 cookie 的域。 路径：请求 URL 中包含这个路径才会把 cookie 发送到服务器。例如，可以指定 cookie 只能由http://www.wrox.com/books/访问，因此访问 http://www.wrox.com/下的页面就不会发送 cookie，即使请求的是同一个域。 过期时间：表示何时删除 cookie 的时间戳（即什么时间之后就不发送到服务器了）。默认情况下，浏览器会话结束后会删除所有 cookie。不过，也可以设置删除 cookie 的时间。这个值是 GMT 格式（Wdy, DD-Mon-YYYY HH:MM:SS GMT），用于指定删除 cookie 的具体时间。这样即使关闭浏览器 cookie 也会保留在用户机器上。把过期时间设置为过去的时间会立即删除 cookie。 安全标志：设置之后，只在使用 SSL 安全连接的情况下才会把 cookie 发送到服务器。例如，请求 https://www.wrox.com 会发送 cookie，而请求 http://www.wrox.com 则不会 这些参数在 Set-Cookie 头部中使用分号加空格隔开 js中操作cookie12345678910111213141516171819202122232425262728293031323334353637class CookieUtil { static get(name) { let cookieName = `${encodeURIComponent(name)}=`, cookieStart = document.cookie.indexOf(cookieName), cookieValue = null; if (cookieStart &gt; -1) { let cookieEnd = document.cookie.indexOf(';', cookieStart); if (cookieEnd == -1) { cookieEnd = document.cookie.length; } cookieValue = decodeURIComponent( document.cookie.substring(cookieStart + cookieName.length, cookieEnd) ); } return cookieValue; } static set(name, value, expires, path, domain, secure) { let cookieText = `${encodeURIComponent(name)}=${encodeURIComponent(value)}`; if (expires instanceof Date) { cookieText += `; expires=${expires.toGMTString()}`; } if (path) { cookieText += `; path=${path}`; } if (domain) { cookieText += `; domain=${domain}`; } if (secure) { cookieText += '; secure'; } document.cookie = cookieText; } static unset(name, path, domain, secure) { CookieUtil.set(name, '', new Date(0), path, domain, secure); }} 子cookie为绕过浏览器对每个域 cookie 数的限制，有些开发者提出了子 cookie 的概念。子 cookie 是在单个cookie 存储的小块数据，本质上是使用 cookie 的值在单个 cookie 中存储多个名/值对。最常用的子 cookie 模式如下： 1name=name1=value1&amp;name2=value2&amp;name3=value3&amp;name4=value4&amp;name5=value5 StorageStorage 类型用于保存名/值对数据，直至存储空间上限（由浏览器决定）。Storage 的实例与其他对象一样，但增加了以下方法 clear()：删除所有值；不在 Firefox 中实现。 getItem(name)：取得给定 name 的值。 key(index)：取得给定数值位置的名称。 removeItem(name)：删除给定 name 的名/值对。 setItem(name, value)：设置给定 name 的值 length 属性可以确定 Storage 对象中保存了多少名/值对 1234 localStorage.setItem('name', 'name');sessionStorage.setItem('age', 25);console.log('length', localStorage.length); //1console.log('lengt1', sessionStorage.length); //1 sessionStorage 对象存储在 sessionStorage 对象中的数据只能由最初存储数据的页面使用，在多页应用程序中的用处有限 实现存储写入时都使用了同步阻塞方式 删除sessionStorage 方法一 delelete 方法二 removeItem12345localStorage.setItem('name', 'name');sessionStorage.setItem('age', 25);delete sessionStorage['age'];console.log('length', localStorage.length); //1console.log('lengt1', sessionStorage.length); //0 localStorage 对象访问同一个 localStorage 对象，页面必须来自同一个域（子域不可以）、在相同的端口上使用相同的协议。 存储事件每当 Storage 对象发生变化时，都会在文档上触发 storage 事件。使用属性或 setItem()设置值、使用 delete 或 removeItem()删除值，以及每次调用 clear()时都会触发这个事件 domain：存储变化对应的域。 key：被设置或删除的键。 newValue：键被设置的新值，若键被删除则为 null。 oldValue：键变化之前的值。 123window.addEventListener(&quot;storage&quot;, (event) =&gt; alert('Storage changed for ${event.domain}')); 对于 sessionStorage 和 localStorage 上的任何更改都会触发 storage 事件，但 storage 事件不会区分这两者。 数据库(IndexedDB) IndexedDB 是类似于 MySQL 或 Web SQL Database 的数据库。与传统数据库最大的区别在于，IndexedDB 使用对象存储而不是表格保存数据。IndexedDB 数据库就是在一个公共命名空间下的一组对象存储，类似于 NoSQL 风格的实现。","link":"/2021/03/05/javascript/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8/"},{"title":"对象","text":"创建对象工厂模式 抽象创建特定对象的过程 缺点：没有解决对象标识问题(即创建的对象是什么类型) 123456789101112function createPerson(name, age, job) { let o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function() { console.log(this.name); }; return o; } let person1 = createPerson(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); let person2 = createPerson(&quot;Greg&quot;, 27, &quot;Doctor&quot;); 构造函数模式12345678910111213function Person(name, age, job){ this.name = name; this.age = age; this.job = job; this.sayName = function() { console.log(this.name); }; } let person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); let person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;); person1.sayName(); // Nicholas person2.sayName(); // Greg 理解构造函数的缺点 构造函数虽然解决了对象标识的问题，但是也带来了其他问题，如果构造函数内部有一个函数，那么每次在实例化的时候，都会重新创建这个函数，而不能实现复用，如果将这个函数放在外部，会导致代码不能聚集 原型模式 使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型 123456789function Person() {} Person.prototype.name = &quot;Nicholas&quot;; Person.prototype.age = 29; Person.prototype.job = &quot;Software Engineer&quot;; Person.prototype.sayName = function() { console.log(this.name); }; let person1 = new Person(); person1.sayName(); // &quot;Nicholas&quot; 理解原型模式的缺点：共享引用类型的数据 构造函数和原型混合的模式12345 function Person(name, age) { this.name = name; this.age = age;}Person.prototype.say = function() {}; 基于动态原型模式 动态原型模式是将原型对象放在构造函数内部，通过变量进行控制，只在第一次生成实例的时候进行原型的设置 动态原型的模式相当于懒汉模式，只在生成实例时设置原型对象，但是功能与构造函数和原型混合模式是相同的 12345678910111213// 动态原型模式function Person(name, age, address) { this.name = name; this.age = age; this.address = address; // 如果Person对象中_initialized 为undeﬁned，则表明还没有为Person的原型对象添加函数 if (typeof Person._initialized === 'undeﬁned') { Person.prototype.getName = function() { return this.name; }; Person._initialized = true; }} 常见面试题对象克隆 克隆是指通过一定的程序将某个变量的值复制至另一个变量的过程。根据复制后的变量与原始变量值的影响情况，克隆可以分为浅克隆和深克隆两种方式 浅克隆方法一：object.assign方法二：扩展运算符方式方法三：concat 拷贝数组方法四：slice 拷贝数组方法五: 手工实现一个浅拷贝 12345678910111213141516 const shallowClone = (target) =&gt; { if (typeof target === 'object' &amp;&amp; target !== null) { const cloneTarget = Array.isArray(target) ? [] : {}; for (let prop in target) { if (target.hasOwnProperty(prop)) { cloneTarget[prop] = target[prop]; } } return cloneTarget; } else { return target; }}; 深克隆方法一： JSON序列化和反序列化这种方法能够解决大部分JSON类型对象的深克隆问题，但是对于以下几个问题不能很好地解决。 无法实现对函数、RegExp等特殊对象的克隆。 对象的constructor会被抛弃，所有的构造函数会指向Object，原型链关系断裂。 对象中如果存在循环引用，会抛出异常方法二：手动实现 对象迭代for…in使用for..in遍历对象是无法直接获取属性值的，因为它实际上遍历的是对象中的所有可枚举属性，你需要手动获取属性值。 for…offor..of循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next()方法来遍历所有返回值。 屏蔽比我们想象中更加复杂。下面我们分析一下如果foo不直接存在于myObject中而是存在于原型链上层时myObject.foo = “bar”会出现的三种情况。 1．如果在[[Prototype]]链上层存在名为foo的普通数据访问属性（参见第3章）并且没有被标记为只读（writable:false），那就会直接在myObject中添加一个名为foo的新属性，它是屏蔽属性。 2．如果在[[Prototype]]链上层存在foo，但是它被标记为只读（writable:false），那么无法修改已有属性或者在myObject上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。 3．如果在[[Prototype]]链上层存在foo并且它是一个setter（参见第3章），那就一定会调用这个setter。foo不会被添加到（或者说屏蔽于）myObject，也不会重新定义foo这个setter。","link":"/2021/03/05/javascript/%E5%AF%B9%E8%B1%A1/"},{"title":"类","text":"类定义定义类也有两种主要方式： 类声明 类表达式。 这两种方式都使用 class 关键字加大括号 不同于函数声明，类声明不会提升,另一个区别则是函数受函数作用域限制，而类受块作用域限制 类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但这些都不是必需的。空的类定义照样有效。默认情况下，类定义中的代码都在严格模式下执行 类上的原型方法类上的方法,都是定义在原型上的且不可枚举 12345class SuperType { sayName() {}}console.log(Object.getOwnPropertyDescriptor(SuperType.prototype, 'sayName').enumerable);//false 类的静态方法类的静态方法是定义在类自身的,可以被子类继承,但是实例不会继承 1234567class SuperType { sayName() {} static sayHelloe() {}}console.log(Object.getOwnPropertyDescriptor(SuperType, 'sayHelloe')); //false 类的继承类继承使用的是新语法，但背后依旧使用的是原型链。 继承基础ES6 类支持单继承。使用 extends 关键字，就可以继承任何拥有[[Construct]]和原型的对象。很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数 构造函数、HomeObject 和 super()派生类的方法可以通过 super 关键字引用它们的原型。这个关键字只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部。在类构造函数中使用 super 可以调用父类构造函数 在静态方法中可以通过 super 调用继承的类上定义的静态方法1234567891011class Vehicle { static identify() { console.log('vehicle'); } } class Bus extends Vehicle { static identify() { super.identify(); } } Bus.identify(); // vehicle 使用super需要注意的 super 只能在派生类构造函数和静态方法中使用 不能单独引用 super 关键字，要么用它调用构造函数，要么用它引用静态方法 调用 super()会调用父类构造函数，并将返回的实例赋值给 this super()的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入 如果没有定义类构造函数，在实例化派生类时会调用 super()，而且会传入所有传给派生类的参数 在类构造函数中，不能在调用 super()之前引用 this。 如果在派生类中显式定义了构造函数，则要么必须在其中调用 super()，要么必须在其中返回一个对象。 抽象基类有时候可能需要定义这样一个类，它可供其他类继承，但本身不会被实例化。虽然 ECMAScript 没有专门支持这种类的语法 ，但通过 new.target 也很容易实现。new.target 保存通过 new 关键字调用的类或函数。通过在实例化时检测 new.target 是不是抽象基类，可以阻止对抽象基类的实例化： 1234567function Car() { if (new.target === Car) { throw new Error(''); }}new Car(); 另外，通过在抽象基类构造函数中进行检查，可以要求派生类必须定义某个方法。因为原型方法在调用类构造函数之前就已经存在了，所以可以通过 this 关键字来检查相应的方法 1234567891011121314function Car() { if (new.target === Car) { throw new Error(''); } // 要求派生类必须实现run 方法 if (!this.run) { throw new Error(); }}class Bus extends Car { run() {}}new Bus(); 类混入把不同类的行为集中到一个类是一种常见的 JavaScript 模式 123456789101112131415161718192021222324class Vehicle {}let FooMixin = (Superclass) =&gt; class extends Superclass { foo() { console.log('foo'); }};let BarMixin = (Superclass) =&gt; class extends Superclass { bar() { console.log('bar'); }};let BazMixin = (Superclass) =&gt; class extends Superclass { baz() { console.log('baz'); }};function mix(BaseClass, ...Mixins) { return Mixins.reduce((accumulator, current) =&gt; current(accumulator), BaseClass);}class Bus extends mix(Vehicle, FooMixin, BarMixin, BazMixin) {}let b = new Bus();b.foo(); // foob.bar(); // barb.baz(); // baz 注意： Object.assign()方法是为了混入对象行为而设计的。只有在需要混入类的行为时才有必要自己实现混入表达式。如果只是需要混入多个对象的属性，那么使用Object.assign()就可以了。 私有属性实现的方式 前置下划线(这是一个约定,并不能阻止被调用) 直接提取出来不写在类里面 Symbol 唯一性 1234567891011121314151617const bar = Symbol('bar');const snaf = Symbol('snaf');export default class myClass{ // 公有方法 foo(baz) { this[bar](baz); } // 私有方法 [bar](baz) { return this[snaf] = baz; } // ...}; #表示 12345678910class IncreasingCounter { #count = 0; get value() { console.log('Getting the current value!'); return this.#count; } increment() { this.#count++; }} 类的 prototype 属性和__proto__属性大多数浏览器的 ES5 实现之中，每一个对象都有proto属性，指向对应的构造函数的 prototype 属性。Class 作为构造函数的语法糖，同时有 prototype 属性和proto属性，因此同时存在两条继承链。 子类的__proto**属性，表示构造函数的继承，总是指向父类。 子类 prototype 属性的__proto**属性，表示方法的继承，总是指向父类的 prototype 属性 12345678class A {}class B extends A {}B.__proto__ === A // trueB.prototype.__proto__ === A.prototype // true 上面代码中，子类 B 的proto属性指向父类 A，子类 B 的 prototype 属性的proto属性指向父类 A 的 prototype 属性。 这样的结果是因为，类的继承是按照下面的模式实现的。 12345678910111213class A {}class B {}// B 的实例继承 A 的实例Object.setPrototypeOf(B.prototype, A.prototype);// B 继承 A 的静态属性Object.setPrototypeOf(B, A);const b = new B(); ES5/ES6 的继承除了写法以外还有什么区别 class 声明会提升，但不会初始化赋值，进行暂时性死区,类似let const class 声明内部会使用严格模式 class的所有方法(原型方法和静态方法)都是不可枚举的 class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有[[construct]]，不能使用 new 来调用。 必须使用 new 调用 class。 class 内部无法重写类名。\\","link":"/2021/03/05/javascript/%E7%B1%BB/"},{"title":"继承","text":"原型链继承ECMA-262 把原型链定义为 ECMAScript 的主要继承方式 每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。 123456789101112function SuperType() { this.property = true; } SuperType.prototype.getSuperValue = function() { return this.property; }; function SubType() { this.subproperty = false; }// 继承 SuperType SubType.prototype = new SuperType(); let instance = new SubType(); 默认原型默认情况下，所有引用类型都继承自 Object，这也是通过原型链实现的。任何函数的默认原型都是一个 Object 的实例，这意味着这个实例有一个内部指针指向Object.prototype。这也是为什么自定义类型能够继承包括 toString()、valueOf()在内的所有默认方法的原因。因此前面的例子还有额外一层继承关系 原型与继承关系原型与实例的关系可以通过两种方式来确定。 第一种方式是使用 instanceof 操作符，如果一个实例的原型链中出现过相应的构造函数，则 instanceof 返回 true 第二种方式是使用 isPrototypeOf()方法。原型链中的每个原型都可以调用这个方法，如下例所示，只要原型链中包含这个原型，这个方法就返回 true 关于方法子类有时候需要覆盖父类的方法，或者增加父类没有的方法。为此，这些方法必须在原型赋值之后再添加到原型上 原型链继承的缺点 在使用原型实现继承时，原型实际上变成了另一个类型的实例。这意味着原先的实例属性摇身一变成为了原型属性 子类型在实例化时不能给父类型的构造函数传参 盗用构造函数 在子类构造函数中调用父类构造函数。因为毕竟函数就是在特定上下文中执行代码的简单对象，所以可以使用apply()和 call()方法以新创建的对象为上下文执行构造函数 123456789101112function SuperType() { this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; } function SubType() { // 继承 SuperType SuperType.call(this); } let instance1 = new SubType(); instance1.colors.push(&quot;black&quot;); console.log(instance1.colors); // &quot;red,blue,green,black&quot; let instance2 = new SubType(); console.log(instance2.colors); // &quot;red,blue,green&quot; 盗用构造函数的缺点必须在构造函数中定义方法因此函数不能重用。此外，子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式 组合继承 使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性 组合继承弥补了原型链和盗用构造函数的不足，是 JavaScript 中使用最多的继承模式。而且组合继承也保留了 instanceof 操作符和 isPrototypeOf()方法识别合成对象的能力 1234567891011121314151617181920212223242526function SuperType(name){ this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; } SuperType.prototype.sayName = function() { console.log(this.name); }; function SubType(name, age){ // 继承属性 SuperType.call(this, name); this.age = age; } // 继承方法SubType.prototype = new SuperType(); SubType.prototype.sayAge = function() { console.log(this.age); }; let instance1 = new SubType(&quot;Nicholas&quot;, 29); instance1.colors.push(&quot;black&quot;); console.log(instance1.colors); // &quot;red,blue,green,black&quot; instance1.sayName(); // &quot;Nicholas&quot;; instance1.sayAge(); // 29 let instance2 = new SubType(&quot;Greg&quot;, 27); console.log(instance2.colors); // &quot;red,blue,green&quot; instance2.sayName(); // &quot;Greg&quot;; instance2.sayAge(); // 27 理解组合继承的缺点：组合继承其实也存在效率问题。最主要的效率问题就是父类构造函数始终会被调用两次 原型链继承使用场景你有一个对象，想在它的基础上再创建一个新对象。你需要把这个对象先传给 object()，然后再对返回的对象进行适当修改 12345function object(o) { function F() {} F.prototype = o; return new F(); } ECMAScript 5 通过增加 Object.create()方法将原型式继承的概念规范化了 寄生式继承 创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象 1234567function createAnother(original){ let clone = object(original); // 通过调用函数创建一个新对象 clone.sayHi = function() { // 以某种方式增强这个对象 console.log(&quot;hi&quot;); }; return clone; // 返回这个对象} 注意:通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似。 寄生式组合继承 寄生式组合继承通过盗用构造函数继承属性，但使用混合式原型链继承方法。基本思路是不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本 寄生式组合继承可以算是引用类型继承的最佳模式 123456789101112131415161718192021function inheritPrototype(subType, superType) { let prototype = object(superType.prototype); // 创建对象 prototype.constructor = subType; // 增强对象 subType.prototype = prototype; // 赋值对象}function SuperType(name) { this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; } SuperType.prototype.sayName = function() { console.log(this.name); }; function SubType(name, age) { SuperType.call(this, name); this.age = age; } inheritPrototype(SubType, SuperType); SubType.prototype.sayAge = function() { console.log(this.age); }; 面试题new,call,appy,bind的手动实现 new 的实现1234567891011121314function _new(ctor, ...args) { if (typeof ctor !== 'function') { throw 'ctor must be a function'; } // 1. 创建一个新对象 let obj = new Object(); //2 将新对象的[[prototype]] 指向函数的prototype obj.__proto__ = Object.create(ctor.prototype); let res = ctor.apply(obj, [...args]); let isObject = typeof res === 'object' &amp;&amp; typeof res !== null; let isFunction = typeof res === 'function'; return isObject || isFunction ? res : obj;}","link":"/2021/03/05/javascript/%E7%BB%A7%E6%89%BF/"},{"title":"js中的array","text":"理解数组 数组（Array）是有序的元素序列。若将有限个类型相同的变量的集合命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。用于区分数组的各个元素的数字编号称为下标 上面是百度百科对数组的解释：我们可以看出数组在内存中是一段连续的同类型的数据空间 js中数组的表现了？我们先看MDN 对数组的定义 数组是一种类列表对象，它的原型中提供了遍历和修改元素的相关操作。JavaScript 数组的长度和元素类型都是非固定的。因为数组的长度可随时改变，并且其数据在内存中也可以不连续，所以 JavaScript 数组不一定是密集型的，这取决于它的使用方式 123const arr=[1,2,3]arr.name=&quot;数组&quot;console.log(arr.name)//&quot;数组&quot; 从上面的代码我们可以看出来并不满足上面数组的定义。 其实这是因为js中的数组是一个特殊的对象 创建数组在js中创建一个数组一共有二种方法，分别是 字面量创建 Array构造函数创建和new Array() 当我们使用Array构造函数创建数组的时候，当我们传入的参数只有一个数值(n)的时候，代表需要创建长度为n的数组，如果传入的参数是一系列参数，代表创建长度为参数的个数，且只包含这些参数 1234new Arrray(5)//[empty × 5]new Array(5,1)//[5,1]new Array(&quot;a&quot;)//[&quot;a&quot;]console.log(new Array({ length: 3 })); //[{length:3}] 注意：这里有一个细节问题，就是当我们传入的参数为一个数值的时候，会带来数组空位的问题 数组静态方法Array.from Array.from() 方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。它的语法如下： 1234Array.from(arrayLike[, mapFn[, thisArg]])arrayLike: 想要转换成数组的伪数组对象(包含length)或可迭代对象。mapFn:可选， 如果指定了该参数，新数组中的每个元素会执行该回调函数。也就是支持一个映射函数thisArg:可选参数，执行回调函数 mapFn 时 this 对象。 下面是针对他的使用案例 12console.log(Array.from('abc')); //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]console.log(Array.from('abc', (val) =&gt; val + 2)); // [&quot;a2&quot;, &quot;b2&quot;, &quot;c2&quot;] Array.of Array.of() 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。 12345678console.log(Array.of(1, 2, 3)); // [1, 2, 3]console.log(Array.of(7))//[7] //polyfill方法 if (!Array.of) { Array.of = function() { return Array.prototype.slice.call(arguments); }; } Arrray.from Array.isArray() 用于确定传递的值是否是一个 Array。 如果对象是 Array ，则返回true，否则为false。 instanceof 和 isArray当检测Array实例时, Array.isArray 优于 instanceof,因为Array.isArray能检测iframes. 关于数组的length length 属性的值是一个 0 到 232-1 的整数。 数组的长度在属性描述符里面是，可修改不可删除和遍历的 数组的length在使用上有一个需要注意的点，当我们进行增删数组的时候，数组长度会自动变化，当我们将Length长度变大的时候，数组元素会自动扩充，当我们改小Length的时候，会移除部分元素 123456const a = [];a.length = 5;console.log(a);//&lt;5 empty items&gt; a.length=3console.log(a)//[ &lt;3 empty items&gt; ] 理解数组空位 数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位 1Array(3) // [, , ,] 注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。 120 in [, , ,] // false0 in [undefined, undefined, undefined] // true ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。 forEach(), filter(), reduce(), every() 和some()都会跳过空位。 map()会跳过空位，但会保留这个值 join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。1234567891011121314151617181920212223// forEach方法[,'a'].forEach((x,i) =&gt; console.log(i)); // 1// filter方法['a',,'b'].filter(x =&gt; true) // ['a','b']// every方法[,'a'].every(x =&gt; x==='a') // true// reduce方法[1,,2].reduce((x,y) =&gt; x+y) // 3// some方法[,'a'].some(x =&gt; x !== 'a') // false// map方法[,'a'].map(x =&gt; 1) // [,1]// join方法[,'a',undefined,null].join('#') // &quot;#a##&quot;// toString方法[,'a',undefined,null].toString() // &quot;,a,,&quot; ES6 则是明确将空位转为undefined。 for…of循环也会遍历空位。 123456let arr = [, ,];for (let i of arr) { console.log(1);}// 1// 1 entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。 1234567891011121314// entries()[...[,'a'].entries()] // [[0,undefined], [1,&quot;a&quot;]]// keys()[...[,'a'].keys()] // [0,1]// values()[...[,'a'].values()] // [undefined,&quot;a&quot;]// find()[,'a'].find(x =&gt; true) // undefined// findIndex()[,'a'].findIndex(x =&gt; true) // 0 Array 原型上的方法修改器方法copywithin copyWithin() 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。语法如下： arr.copyWithin(target[, start[, end]])target0 为基底的索引，复制序列到该位置。如果是负数，target 将从末尾开始计算。如果 target 大于等于 arr.length，将会不发生拷贝。如果 target 在 start 之后，复制的序列将被修改以符合 arr.length。 start0 为基底的索引，开始复制元素的起始位置。如果 start 被忽略，copyWithin 将会从0开始复制。如果 start 为负，则其指定的索引位置等同于 length+start，length 为数组的长度。end 也是如此。 end0 为基底的索引，开始复制元素的结束位置。copyWithin 将会拷贝到该位置，但不包括 end 这个位置的元素。如果 end 被忽略，copyWithin 方法将会一直复制至数组结尾（默认为 arr.length） copyWithin 方法不要求其 this 值必须是一个数组对象；除此之外，copyWithin 是一个可变方法，它可以改变 this 对象本身，并且返回它，而不仅仅是它的拷贝。 123456789101112[1, 2, 3, 4, 5].copyWithin(-2)// [1, 2, 3, 1, 2][1, 2, 3, 4, 5].copyWithin(0, 3)// [4, 5, 3, 4, 5][1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5][1, 2, 3, 4, 5].copyWithin(-2, -3, -1)// [1, 2, 3, 3, 4] fill fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。语法如下 arr.fill(value[, start[, end]]) value 用来填充数组元素的值。 start 可选 起始索引，默认值为0。 end 可选 终止索引，默认值为 this.length。 如果 start 是个负数, 则开始索引会被自动计算成为 length+start, 其中 length 是 this 对象的 length 属性值。如果 end 是个负数, 则结束索引会被自动计算成为 length+end。 fill 方法故意被设计成通用方法, 该方法不要求 this 是数组对象。 fill 方法是个可变方法, 它会改变调用它的 this 对象本身, 然后返回它, 而并不是返回一个副本。 当一个对象被传递给 fill方法的时候, 填充数组的是这个对象的引用。 12345678910111213141516[1, 2, 3].fill(4); // [4, 4, 4][1, 2, 3].fill(4, 1); // [1, 4, 4][1, 2, 3].fill(4, 1, 2); // [1, 4, 3][1, 2, 3].fill(4, 1, 1); // [1, 2, 3][1, 2, 3].fill(4, 3, 3); // [1, 2, 3][1, 2, 3].fill(4, -3, -2); // [4, 2, 3][1, 2, 3].fill(4, NaN, NaN); // [1, 2, 3][1, 2, 3].fill(4, 3, 5); // [1, 2, 3]Array(3).fill(4); // [4, 4, 4][].fill.call({ length: 3 }, 4); // {0: 4, 1: 4, 2: 4, length: 3}// Objects by reference.var arr = Array(3).fill({}) // [{}, {}, {}];// 需要注意如果fill的参数为引用类型，会导致都执行都一个引用类型// 如 arr[0] === arr[1] 为truearr[0].hi = &quot;hi&quot;; // [{ hi: &quot;hi&quot; }, { hi: &quot;hi&quot; }, { hi: &quot;hi&quot; }] pushpopshiftunshift unshift() 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度(该方法修改原有数组)。 sort sort() 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的 如果没有指明 compareFunction ，那么元素会按照转换为的字符串的诸个字符的Unicode位点进行排序。例如 “Banana” 会被排列到 “cherry” 之前。当数字按由小到大排序时，9 出现在 80 之前，但因为（没有指明 compareFunction），比较的数字会先被转换为字符串，所以在Unicode顺序上 “80” 要比 “9” 要靠前。 使用映射改善排序 compareFunction 可能需要对元素做多次映射以实现排序，尤其当 compareFunction 较为复杂，且元素较多的时候，某些 compareFunction 可能会导致很高的负载。使用 map 辅助排序将会是一个好主意。基本思想是首先将数组中的每个元素比较的实际值取出来，排序后再将数组恢复 1234567891011121314151617// 需要被排序的数组var list = ['Delta', 'alpha', 'CHARLIE', 'bravo'];// 对需要排序的数字和位置的临时存储var mapped = list.map(function(el, i) { return { index: i, value: el.toLowerCase() };})// 按照多个值排序数组mapped.sort(function(a, b) { return +(a.value &gt; b.value) || +(a.value === b.value) - 1;});// 根据索引得到排序的结果var result = mapped.map(function(el){ return list[el.index];}); reverse方法 reverse() 方法将数组中元素的位置颠倒，并返回该数组。数组的第一个元素会变成最后一个，数组的最后一个元素变成第一个。该方法会改变原数组。 reverse方法是特意类化的；此方法可被 called 或 applied于类似数组对象。对象如果不包含反映一系列连续的、基于零的数值属性中的最后一个长度的属性，则该对象可能不会以任何有意义的方式运行。 如：颠倒类数组中的元素 1234const a = { 0: 1, 1: 2, 2: 3, length: 3 };Array.prototype.reverse.call(a);console.log(a); // {0: 3, 1: 2, 2: 1, length: 3} Array.prototype.splice() splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。语法：array.splice(start[, deleteCount[, item1[, item2[, …]]]]) start​指定修改的开始位置（从0计数）。如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表示从数组末位开始的第几位（从-1计数，这意味着-n是倒数第n个元素并且等价于array.length-n）；如果负数的绝对值大于数组的长度，则表示开始位置为第0位。 deleteCount 可选整数，表示要移除的数组元素的个数。如果 deleteCount 大于 start 之后的元素的总数，则从 start 后面的元素都将被删除（含第 start 位）。如果 deleteCount 被省略了，或者它的值大于等于array.length - start(也就是说，如果它大于或者等于start之后的所有元素的数量)，那么start之后数组的所有元素都会被删除。如果 deleteCount 是 0 或者负数，则不移除元素。这种情况下，至少应添加一个新元素。 item1, item2, … 可选要添加进数组的元素,从start 位置开始。如果不指定，则 splice() 将只删除数组元素。 访问方法 下面的这些方法绝对不会改变调用它们的对象的值，只会返回一个新的数组或者返回一个其它的期望值。 concat 方法 concat()方法可以在现有数组全部元素基础上创建一个新数组。它首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组 如果传入的一组参数中，包含的有数组就将数组打平展开(双重嵌套的数组不会进行此操作) 12console.log([1, 2, 3].concat(4, [5, 6])); //[1,2,3,4,5,6]console.log([1, 2, 3].concat(4, [5, [6]])); //[1,2,3,4,5,[6]] concat方法不会改变this或任何作为参数提供的数组，而是返回一个浅拷贝，它包含与原始数组相结合的相同元素的副本。 原始数组的元素将复制到新数组中，如下所示： 对象引用（而不是实际对象）：concat将对象引用复制到新数组中。 原始数组和新数组都引用相同的对象。 也就是说，如果引用的对象被修改，则更改对于新数组和原始数组都是可见的。 这包括也是数组的数组参数的元素。 数据类型如字符串，数字和布尔（不是String，Number 和 Boolean 对象）：concat将字符串和数字的值复制到新数组中。 注意：可以阻止打平数组 打平数组参数的行为可以重写，方法是在参数数组上指定一个特殊的符号：Symbol.isConcatSpreadable。这个符号能够阻止 concat()打平参数数组。相反，把这个值设置为 true 可以强制打平类数组对象 12345678910111213let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; let newColors = [&quot;black&quot;, &quot;brown&quot;]; let moreNewColors = { [Symbol.isConcatSpreadable]: true, length: 2, 0: &quot;pink&quot;, 1: &quot;cyan&quot; }; newColors[Symbol.isConcatSpreadable] = false; // 强制不打平数组let colors2 = colors.concat(&quot;yellow&quot;, newColors); // 强制打平类数组对象let colors3 = colors.concat(moreNewColors); inclueds includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。语法如下：arr.includes(valueToFind[, fromIndex])valueToFind： 需要查找的元素值。fromIndex: 从fromIndex 索引处开始查找 valueToFind。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜,如果计算出来的值还是小于0，那么整个数组都会被搜索。默认为 0。如果 fromIndex 大于等于数组的长度，则会返回 false，且该数组不会被搜索。 123456var arr = ['a', 'b', 'c'];arr.includes('a', -100); // truearr.includes('b', -100); // truearr.includes('c', -100); // truearr.includes('a', -2); // false JOIn方法 join() 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。 12345ar a = ['Wind', 'Rain', 'Fire'];var myVar1 = a.join(); // myVar1的值变为&quot;Wind,Rain,Fire&quot;var myVar2 = a.join(', '); // myVar2的值变为&quot;Wind, Rain, Fire&quot;var myVar3 = a.join(' + '); // myVar3的值变为&quot;Wind + Rain + Fire&quot;var myVar4 = a.join(''); // myVar4的值变为&quot;WindRainFire&quot; 如果数组中某一项是 null 或 undefined，则在 join()、toLocaleString()、toString()和 valueOf()返回的结果中会以空字符串表示 slice 方法 slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。 语法 arr.slice([begin[, end]]) begin 可选提取起始处的索引（从 0 开始），从该索引开始提取原数组元素。如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取，slice(-2) 表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。如果省略 begin，则 slice 从索引 0 开始。如果 begin 超出原数组的索引范围，则会返回空数组。 end 可选提取终止处的索引（从 0 开始），在该索引处结束提取原数组元素。slice 会提取原数组中索引从 begin 到 end 的所有元素（包含 begin，但不包含 end）。slice(1,4) 会提取原数组中从第二个元素开始一直到第四个元素的所有元素 （索引为 1, 2, 3的元素）。如果该参数为负数， 则它表示在原数组中的倒数第几个元素结束抽取。 slice(-2,-1) 表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。如果 end 被省略，则 slice 会一直提取到原数组末尾。如果 end 大于数组的长度，slice 也会一直提取到原数组末尾。 indexOf indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 语法如下 arr.indexOf(searchElement[, fromIndex]) fromIndex 可选开始查找的位置。如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回-1。如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消，即-1表示从最后一个元素开始查找，-2表示从倒数第二个元素开始查找 ，以此类推。 注意：如果参数中提供的索引值是一个负值，并不改变其查找顺序，查找顺序仍然是从前向后查询数组。如果抵消后的索引值仍小于0，则整个数组都将会被查询。其默认值为0. lastIndexOf lastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。语法: arr.lastIndexOf(searchElement[, fromIndex]) fromIndex 可选 从此位置开始逆向查找。默认为数组的长度减 1(arr.length - 1)，即整个数组都被查找。如果该值大于或等于数组的长度，则整个数组会被查找。如果为负值，将其视为从数组末尾向前的偏移。即使该值为负，数组仍然会被从后向前查找。如果该值为负时，其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。 迭代方法在下面的众多遍历方法中，有很多方法都需要指定一个回调函数作为参数。在每一个数组元素都分别执行完回调函数之前，数组的length属性会被缓存在某个地方，所以，如果你在回调函数中为当前数组添加了新的元素，那么那些新添加的元素是不会被遍历到的。此外，如果在回调函数中对当前数组进行了其它修改，比如改变某个元素的值或者删掉某个元素，那么随后的遍历操作可能会受到未预期的影响 entries，keys,values 方法forEach forEach() 方法对数组的每个元素执行一次给定的函数。 语法：arr.forEach(callback(currentValue [, index [, array]])[, thisArg]) callback：为数组中每个元素执行的函数，该函数接收一至三个参数： currentValue:数组中正在处理的当前元素。 index: 可选数组中正在处理的当前元素的索引。 array 可选forEach() 方法正在操作的数组。 thisArg 可选:可选参数。当执行回调函数 callback 时，用作 this 的值。如果 thisArg 参数有值，则每次 callback 函数被调用时，this 都会指向 thisArg 参数。如果省略了 thisArg 参数，或者其值为 null 或 undefined，this 则指向全局对象。按照函数观察到 this 的常用规则，callback 函数最终可观察到 this 值，注意：如果使用箭头函数表达式来传入函数参数， thisArg 参数会被忽略，因为箭头函数在词法上绑定了 this 值。 注意：除了抛出异常以外，没有办法中止或跳出 forEach() 循环。如果你需要中止或跳出循环，forEach() 方法不是应当使用的工具。 forEach() 遍历的范围在第一次调用 callback 前就会确定。调用 forEach 后添加到数组中的项不会被 callback 访问到。如果已经存在的值被改变，则传递给 callback 的值是 forEach() 遍历到他们那一刻的值。已删除的项不会被遍历到。如果已访问的元素在迭代时被删除了（例如使用 shift()），之后的元素将被跳过 使用forEach需要注意以下几点 使用forEach遍历包含空位的数组(会跳过空位)123456789101112131415const arraySparse = [1, 3, , 7];let numCallbackRuns = 0;arraySparse.forEach(function(element, index) { console.log(element, index); // index还是正常的哦 numCallbackRuns++;});console.log('numCallbackRuns: ', numCallbackRuns);// 1 0// 3 1// 7 3// numCallbackRuns: 3 在遍历的时候操作了原数组1234567891011121314151617181920212223242526// 移除一个元素var words = ['one', 'two', 'three', 'four'];words.forEach(function(word) { console.log(word); if (word === 'two') { words.shift(); }});// one// two// four// 新增一个元素(并不会导致多遍历一次)var words = ['one', 'two', 'three', 'four'];words.forEach(function(word, index) { console.log(word); if (word === 'two') { words.push(1231); }});// one;// two;// three;// fou; every 方法 every() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。 若收到一个空数组，此方法在一切情况下都会返回 true。 语法：arr.every(callback(element[, index[, array]])[, thisArg]) 实现 every Polyfill 12345678910111213141516Array.prototype.myEvery = function(fn, context) { if (typeof callback !== 'function') { throw Error('错误'); } let passed = true; for (let i = 0; i &lt; len; i++) { // 判断这个属性是否在对象上 if (Object.prototype.hasOwnProperty.call(this, i)) { if (!passed) { break; } passed = !!callback.call(context, this[i], i, this); } } return passed; }; map() map() 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。 语法： 123var new_array = arr.map(function callback(currentValue[, index[, array]]) { // Return element for new_array }[, thisArg]) map 方法处理数组元素的范围是在 callback 方法第一次调用之前就已经确定了。调用map方法之后追加的数组元素不会被callback访问。如果存在的数组元素改变了，那么传给callback的值是map访问该元素时的值。在map函数调用后但在访问该元素前，该元素被删除的话，则无法被访问到。 实现Map Polyfill 123456789101112131415Array.prototype.myMap = function(callback, context) { if (typeof callback !== 'function') { throw Error('错误'); } const result = []; const len = this.length; for (let i = 0; i &lt; len; i++) { // 判断这个属性是否在对象上 if (Object.prototype.hasOwnProperty.call(this, i)) { // 使用call 的原因主要是可能改变context result.push(callback.call(context, this[i], i, this)); } } return result; }; some() some() 方法测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。 如果用一个空数组进行测试，在任何情况下它返回的都是false。 语法：arr.some(callback(element[, index[, array]])[, thisArg]) 1234567891011121314151617 Array.prototype.mysome = function(fn, context) { if (typeof callback !== 'function') { throw Error('错误'); } let passed = false; for (let i = 0; i &lt; len; i++) { // 判断这个属性是否在对象上 if (Object.prototype.hasOwnProperty.call(this, i)) { if (passed) { break; } passed = !!callback.call(context, this[i], i, this); } } return passed;}; filter filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 语法：var newArray = arr.filter(callback(element[, index[, array]])[, thisArg]) find 和 findIndex() find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。 findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。 语法：arr.find(callback(element[, index[, array]])[, thisArg]) 在第一次调用 callback函数时会确定元素的索引范围，因此在 find方法开始执行之后添加到数组的新元素将不会被 callback函数访问到。如果数组中一个尚未被callback函数访问到的元素的值被callback函数所改变，那么当callback函数访问到它时，它的值是将是根据它在数组中的索引所访问到的当前值。被删除的元素仍旧会被访问到，但是其值已经是undefined了。 123456var a = [1, 2, 3, 4, 5];a.find((element) =&gt; { a.push(6); console.log(element);// 1 2 3 4 5}); reduce和reduceRight reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。语法arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue]) callback: 执行数组中每个值 (如果没有提供 initialValue则第一个值除外)的函数，包含四个参数： accumulator: 累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue（见于下方）。 currentValue: 数组中正在处理的元素。 index 可选 数组中正在处理的当前元素的索引。 如果提供了initialValue，则起始索引号为0，否则从索引1起始。 array 可选 调用reduce()的数组initialValue可选 作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。 回调函数第一次执行时，accumulator 和currentValue的取值有两种情况：如果调用reduce()时提供了initialValue，accumulator取值为initialValue，currentValue取数组中的第一个值；如果没有提供 initialValue，那么accumulator取数组中的第一个值，currentValue取数组中的第二个值。 注意：如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始。 如果数组为空且没有提供initialValue，会抛出TypeError 。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。 其他方法flat flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。指定要提取嵌套数组的结构深度，默认值为 1。 flat() 方法会移除数组中的空项:123var arr4 = [1, 2, , 4, 5];arr4.flat();// [1, 2, 4, 5] 需要思考flat的各种替代方案参考链接 数组转为其他类型 数组转boolean(永远转为true) 数组转字符串(先调用valueof再调用toString) 数组转Number(先调用valueOf 再调用toString) 知识拓展 理解什么是关联数组","link":"/2021/03/05/javascript/array/"}],"tags":[{"name":"cookie","slug":"cookie","link":"/tags/cookie/"},{"name":"localstorage","slug":"localstorage","link":"/tags/localstorage/"},{"name":"sessionStroage","slug":"sessionStroage","link":"/tags/sessionStroage/"},{"name":"IndexedDB","slug":"IndexedDB","link":"/tags/IndexedDB/"}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"栈","slug":"数据结构与算法/栈","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%88/"},{"name":"二叉树","slug":"数据结构与算法/二叉树","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"矩阵","slug":"数据结构与算法/矩阵","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%9F%A9%E9%98%B5/"},{"name":"队列","slug":"数据结构与算法/队列","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/"},{"name":"安全算法","slug":"数据结构与算法/安全算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AE%89%E5%85%A8%E7%AE%97%E6%B3%95/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"数组","slug":"数据结构与算法/数组","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/"},{"name":"JSON","slug":"javascript/JSON","link":"/categories/javascript/JSON/"},{"name":"generator","slug":"javascript/generator","link":"/categories/javascript/generator/"},{"name":"Object","slug":"javascript/Object","link":"/categories/javascript/Object/"},{"name":"promise","slug":"javascript/promise","link":"/categories/javascript/promise/"},{"name":"this","slug":"javascript/this","link":"/categories/javascript/this/"},{"name":"客户端存储","slug":"javascript/客户端存储","link":"/categories/javascript/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8/"},{"name":"创建对象","slug":"javascript/创建对象","link":"/categories/javascript/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/"},{"name":"类","slug":"javascript/类","link":"/categories/javascript/%E7%B1%BB/"},{"name":"继承","slug":"javascript/继承","link":"/categories/javascript/%E7%BB%A7%E6%89%BF/"},{"name":"数组","slug":"javascript/数组","link":"/categories/javascript/%E6%95%B0%E7%BB%84/"}]}